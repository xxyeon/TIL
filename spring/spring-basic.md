## IoC(Inversion of Control)

**제어의 주인이 프레임워크이다.**
@Configuration으로 등록한 설정파일에 의해 구현체의 의존관계가 설정되므로 개발자 입장에선 어떤 구현체가 사용되는지 모른다.  
우리가 new로 직접 인스턴스를 생성하지 않으니 어떤 구현체가 들어올지 모름. 의존성 주입도 스프링의 생태계에서 정해진 대로 빈 주입이 되는 것이 제어의 흐름이 프레임워크에 있다는 것이다.  
프로그램에 대한 제어흐름을 설정 파일(외부)이 가지고 있다.

### 라이브러리 vs 프레임워크

- 라이브러리: 제어의 흐름이 개발자에게 있다.
- 프레임워크: 제어의 흐름이 프레임워크에 있다.

##

## ⭐️의존관계 주입

> 애플리케이션 실행 시점에 **외부에서 실제 구현 객체를 생성**하고 클라이언트에 **전달**해서 클라이언트와 서버의 실제 **의존관계가 연결** 되는 것을 의존관계 주입(DI)라 고 한다.  
> 객체를 실제로 생성하는 코드가 없이 애플리케이션 실행 시점에 외부에서 생성해주고 주입을 해준다. 따라서 인터페이스에만 의존할 수 있는 것

1. 정적인 클래스 의존관계: import 코드를 보고 판단 가능 -> 애플리케이션을 실행하지 않아도 분석 가능

- intelliJ에서 클래스 다이어그램으로 볼 수 있는 관계를 말함

2. 동적인 클래스 의존관계: 애플리케이션 실행 시점에 실제 생성된 인스턴스와 연결된 의존관계

- 인터페이스는 어떤걸 의존하는지 정적으로 알 수 있으나, 구현체가 스프링이 어떤 걸 선택해서 주입해줄지 실행되지 않는한 모른는 것

### 장점

- 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다. -> 인터페이스를 구현해서 동일한 타입을 가진 클래스로 갈아끼울 수 있다.
- 정적인 클래스 의존관계를 변경하지 않고(=클라이언트 코드를 변경하지 않고), 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다. -> 인터페이스에만 의존하면 된다, 순수 자바 코드로 테스트를 할 경우 의존관계 주입이 불가능하명 NPE가 발생한다.

## IoC 컨테이너, DI 컨테이너

spring 설정파일에서 객체를 생성하고 의존관계를 연결해주는 것을 IoC컨테이너 또는 DI 컨테이너라고 한다.
IoC 용어는 너무 범용적이라 의존관계 주입에 초점을 맞추어 최근에는 주로 DI 컨테이너라고도 한다.

## 의존관계 주입 방법

1. **생성자 주입**: 생성자 호출 시점에 딱 한번 호출되는 것을 보장한다. 불편, 필수 의존관계일 경우 사용한다. 생성자가 하나일 때는 @Autowired를 생략할 수 있다. 빈을 등록하기 위해 객체를 생성해야함. 결국 빈이 등록되는 동시에 의존관계가 주입된다.
2. **수정자 주입(setter)**: setter 메서드로 의존관계를 설정해주는 것이다.
   스프링이 모든 빈을 컨테이너에 등록하고, @Autowired 어노테이션이 붙은 setter 메서드를 인식해서 의존관계를 자동으로 주입해준다. 의존관계를 수정할 수 있으므로 선택, 변겨 가능성이 있는 의존관계에 사용
3. **필드 주입**: 필드에 @Autowired를 붙여서 주입해줄 수 있다. 외부에서 변경이 불가능하다는 단점이 있다. (setter도 없고 생성자도 없어서 의존관계 주입이 @Autowired에만 의존한다. DI프레임워크가 없으면 동적 클래스 의존관계를 맺을 수가 없다.)
4. **일반 메서드 주입**: 메서드에 @Autowired를 붙여서 의존관계 주입 대상이 되도록 한다. 한번에 여러 필드를 주입받을 수 있다는 장점이 있지만, 수정자와 생성자 주입 선에서 다 해결되므로 일반적으로 잘 사용하지 않는다.

   - 의존관계 주입 단계에서 @Autowired가 붙은 메서드를 자동으로 호출하여 의존성을 주입한다.

## @Autowired 동작 방법

1. 스프링 애플리케이션이 시작하면서 빈들을 컨테이너에 등록한다
2. @Autowired 어노테이션을 보고 의존관계를 확인하고, 등록된 빈 중에서 동일한 타입의 빈이 있으면 주입해준다.

## 빈 충돌을 해결하는 방법

1. **@Autowired 필드명 매칭**: 타입 매칭을 시도하고, 이때 여러 빈이 있으면 이름, 파라미터 이름으로 빈 이름을 추가 매칭한다. (타입 매칭 시도 후 필드명(또는 파라미터명)으로 빈이름 찾기)
2. **@Quilifier**: Quilifier를 사용해서 추가 구분자를 붙여주는 방법이 있다. 빈 등록시 @Quilifire를 붙여주고, 주입시에 @Quilifier를 붙여주고 등록한 이름을 적어주면 된다. 이렇게 되면 @Quilifier로 등록된 이름을 가진 빈을 조회해서 주입해준다. 만일 @Quilifier로 등록한 빈을 못찾으면 주입시에 @Quilifier 등록한 이름과 동일한 이름을 가진 빈을 찾는다.
3. **@Primary**: Primary는 말 그대로 우선순위를 정해주는 방법이다. @Autowired 시 여러 빈이 매칭되면 @Primary가 붙은 빈이 우선권을 가진다.

## BeanFactory와 ApplicationContext

> 둘 다 스프링 컨테이너라고 한다.

### BeanFactory

- 스프링 컨테이너의 최상위 인터페이스
- 스프링 빈을 관리하고 조회하는 역할을 담당
- getBean() 제공 (Authowired 로 빈 주입시 빈타입 찾을때 사용하는 메서드)

### ApplicationContext

- BeanFactory를 확장한 인터페이스
- 관리, 조회 말고도 수많은 부가기능 제공(예를 들어서 환경변수 설정)
- BeanFactory를 사용할 일은 거의 없고 부가기능이 있는 ApplicationContext만 거의 사용

## 스프링 컨테이너의 생성 과정

스프링 컨테이너를 생성하고, 설정 정보를 참고해서 스프링 빈을 등록한 후, 의존관계를 설정한다.

### 자세한 과정

1. `java new AnnotationConfigAppliationContext(AppConfig.class)`
   위 코드를 실행해서 스프링 컨테이너를 만든다(컨테이너 않에 스프링 빈 저장소가 만들어져있음)
2. 구성 정보(AppConfig.class)를 보고 스프링 빈으로 등록한다. (key: 메서드명, value: 반환하는 구현체)
3. 빈 의존관계 설정을 위한 준비를 한다.

- value에 있는 객체를 생성해준다.

4. 빈 의존관계를 설정을 완료한다.

- 스프링 컨테이너가 설정 정보를 참고해서 의존관계를 주입(DI)한다. -> 동적인 클래스 의존관계 설정

## 빈 등록을 위해 작성하는 설정파일

- java와 xml로 작성할 수 있다.

## 빈 생명주기

> 애플리케이션 시작 시점에 필요한 빈을 모두 생성, 연결하고, 종료 시점에 한번에 없애는 작업
> 객체 생성 -> 의존관계 주입 순으로 이루어진다.(Setter, Field Injection 경우)

- 생성자 주입같은 경우는 예외임. 객체를 만들 때 스프링 빈이 들어와야하므로

### 스프링 빈의 이벤트 라이프사이클

스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입(Setter, Field Injenction) -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료

## 빈스코프

스프링 빈이 존재할 수 있는 범위를 말한다.

1. 싱글톤: 기본 스코프로, 스프링 컨테이너 시작과 종료까지 유지되는 가장 넒은 범위의 스코프이다.
2. 프로토타입: 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 짦은 범위

웹 관련 스코프

- **request**: 웨 요청이 들어오고 나갈 때까지 유지
- session: 웹 세션이 생성되고 종료될 때까지 유지
- application: 웹의 서블릿 컨텍스와 같은 범위로 유지

## POJO(Plain Old Java Object) 란 무엇인가?

POJO는 프레임워크 인터페이스, 클래스를 구현하거나 확장하지 않은 단순한 클래스로 Java에서 제공하는 API 외에 종속되지 않습니다. 특정 환경에 종속되지 않아 코드가 간결하고 테스트 자동화에 유리합니다. 스프링에서는 도메인과 비즈니스 로직을 수행하는 대상이 POJO대상이 될 수 있습니다.

### POJO 프로그래밍이 필요한 이유

- 특정 환경이나 기술에 종속적이지 않으면 재사용이 가능하고, 확장 가능한 유연한 코드를 작성할 수 있다.
- 저수순 레벨의 기술과 환경에 종속적인 코드를 제거하여 코드를 간결해지며 디버깅하기에도 상대적으로 쉬워진다.

### Spring 과 POJO의 관계

> 스프링은 IoC/DI, AOP, PSA 같은 기술을 통해 POJO가 잘 동작하도록 지원하는 프레임워크입니다.  
> Spring은 POJO 프로그래밍을 지향하는 프레임워크이다.  
> 최대한 다른 환경이나 기술에 종속적이지 않도록 하기 위한 POJO 프로그래밍 코드를 작성하기 위해 스프링 프레임워크에서는 IoC/DI, AOP, PSA를 지원하고 있다.

스프링이 POJO를 지향한다는 의미는 스프링은 프레임워크에 종속적인 코드 없이 동작할 수 있도록 설계되었다. 즉 extends SpringSomething, implements ContainerInterface 같은 걸 하지 않아도 스프링이 DI, AOP 등을 적용해 줄 수 있다는 뜻이다.

<details>
<summary>
DI컨테이너를 사용해서 빈을 관리하려면 스프링 컨테이너가 필요하지 않나요?
</summary>
-> DI나 AOP를 하기 위해서는 스프링 IoC(DI) 컨테이너가 필요하긴 함. 근데 개발자가 작성한 객체 자체는 스프링에 종속되지 않아도 되도록 설계되었다는 뜻이다.

```java
// 이런 코드는 프레임워크 종속적임
@Component
public class MyService implements ApplicationContextAware {
    ...
}
```

```java
// 이런 코드는 POJO
public class MyService {
    public void work() { ... }
}
```

스프링이 이 객체를 관리할 수는 있지만, 객체 자체는 스프링을 전혀 몰라도 된다.

</details>

## Configuration의 바이트코드 조작

설정 파일에 동일한 구현체를 반환하는 메서드가 두개 이상이여도 반환되는 객체가 싱글톤을 보장해준다.  
Configuration을 사용하면 스프링이 생성해준는 객체인 CGLIB라는 바이트코드 조작 라이브러리를 사용해서 설정 파일을 상속받은 임의의 다른 클래스를 만들고 해당 클래스를 기반으로 빈을 생성해준다.  
그래서 바이트코드 조작으로 생성된 코드에서는 빈을 생성할때 컨테이너에 동일한 빈이 있으면 재사용하고, 없으면 생성하는 로직이 포함되어 있다.
