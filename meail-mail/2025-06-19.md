# Call By Value와 Call By Reference에 대해서 설명해주세요.

특정 메서드를 호출하는 경우 인자로 전달하는 방법은 크게 2가지가 존재합니다. 값에 의한 호출(Call By Value), 참조에 의한 호출(Call By Reference)이 이에 해당합니다.

- **값에 의한 호출(Call By Value)**: 메서드를 호출할 때 값 자체를 넘겨주는 방식입니다. 메서드를 호출하는 함수(caller)의 변수와 호출된 함수(callee)의 파라미터는 서로 다른 변수입니다.
- **참조에 의한 호출(Call By Reference)**: 메서드를 호출할 때, 참조를 직접 전달하는 방식입니다. 참조를 직접 전달하기 때문에 호출하는 함수의 변수와 호출된 함수의 파라미터는 동일한 변수입니다. 따라서 파라미터를 수정하는 경우 그대로 원본에도 영향을 미칩니다.

## 자바는 Call By Value

자바는 값에 의한 호출만 존재합니다.  
자바의 변수는 스택 영역에 할당됩니다. 이때, 변수의 타입이 원시 타입인 경우에는 값 또한 스택 영역에 저장됩니다. 참조 타입인 경우 객체 자체는 힙 영역에 저장되고 스택 영역에 존재하는 변수가 객체의 주소를 가집니다.

> 참조 타입과 Call By Reference 개념을 제대로 알고 있지 않아서 자바가 Call By Reference라고 착각하고 있었던 거 같다. 변수가 객체의 주소를 가진다 = Call By Reference 로 생각 했었다.

만일 특정 메서드에 원시(Primitive) 타입의 변수를 인자로 전달하여 호출하면, 호출된 메서드의 해당 파라미터가 변경되어도 원본을 수정되지 않는다. 왜냐하면, 호출된 메서드의 스택 프레임에 인자로 주어진 변수의 값이 복사되어 사용되기 때문이다.

반면, 참조 타입의 변수를 인자로 전달하여 호출하는 경우 호출된 메서드 내부에서 파라미터 값을 수정하면 원본 값도 수정된다. 하지만, 이러한 방식은 호출된 메서드의 스택 프레임에 참조 타입 변수를 중복하여 생성하기 때문에 값에 의한 호출(Call By Value)로 판단된다.

## 더 자세히 (C와 자바)

https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%9E%90%EB%B0%94%EB%8A%94-Call-by-reference-%EA%B0%9C%EB%85%90%EC%9D%B4-%EC%97%86%EB%8B%A4-%E2%9D%93  
C와 달리 자바는 포인터를 철저하게 숨겨 개발자가 직접 메모리 주소에 접근하지 못하게 조치했다. C언어는 포인터를 통해서 그대로 주소를 통해 메모리를 참조할 수 있다.
자바에서는 원시값이 **복사** 되느냐, 참조값이 **복사**되느냐 차이가 있을 뿐이다.  
매개변수에 복사된 값에 따라 원시값이면 바로 연산을 하고 주소값이면 해당 메모리 주소를 참조해 값을 가져와 연산할 뿐이다.

### C언어의 Call By Reference

C언어에서는 포인터(\*) 변수를 파라미터로 받게하고 함수를 호출할 때 주소 연산자(&)를 이용해 주소값을 직접 넘겨 직접적인 메모리 참조가 가능하다.

```C
#include <stido.h>

void swap(int *, int *);

int main() {
      int a = 10;
      int b = 20;

      swap(&a, &b);
}

void swap(int *a, int *b) {
      int temp;

      temp = *a;
      *a = *b;
      *b = temp;
}
```

call by reference 로 변수의 값을 다루게 되면, 메모리를 절약할 수 있으며 속도도 빨라진다는 장점이 있기 때문에 대부분의 임베디드 환경에서는 C 포인터를 이용해 코딩한다. Call By Value는 변수에 할당된 데이터 크기만큼 또 메모리 공간을 사용해야하므로 메모리를 많이 사용함.

## JVM Runtim Area(JVM의 메모리 영역)

> \*Stack Frame
> 스택 영역에 차례대로 저장되는 함수의 호출을 Stack Frame 이라고 부른다. (하나의 메서드에 필요한 메모리 덩이리)
> 메서드가 호출될때마다 메서드 콜스택이 스택 프레임이라는 스택 메모리에 쌓이게 되고, 메서드 수행이 끝나면 프레임 별로 삭제한다.

- 기본(primitive)타입 변수는 Stack 영역에 직접 값을 가진다.
- 참조(reference) 타입 변수는 Heap 영역이나 Method 영역에 객체 주소를 가진다.
