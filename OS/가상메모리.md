## 메모리 관리 전략

### 단편화는 왜 생기는가?

프로세스가 메모리에 올라갔다가 스케줄러에 의해 다시 보조기억장치로 swapping되는 과정이 반복적으로 일어나면서 메모리 단편화가 생긴다.

- swap-in: 보조 기억 장치 -> ram
- swap-out: ram -> 보조기억 장치

1. 외부 단편화: 메모리 공간 중 **사용하지 못하게 되는** 일부분, 물리 메모리 공간들을 모두 합치면 충분한 공간이 되는 부분들이 분산되어 있을 때 발생한다. -> 프로세스가 외부 단편화로 인해 못들어감, 모두 합치면 충분히 들어갈 수 있는데... 사용하지 못함
2. 내부 단편화: **프로세스가 사용하는** 메모리 공간에 포함된 남은 부분

압축 : 외부 단편화를 해소하기 위해 프로세스가 사용하는 공간들을 한쪽으로 몰아, 자유공간을 확보하는 방법론 이지만, 작업효율이 좋지 않다. (위의 메모리 현황이 압축을 통해 아래의 그림 처럼 바뀌는 효과를 가질 수 있다)축 : 외부 단편화를 해소하기 위해 프로세스가 사용하는 공간들을 한쪽으로 몰아, 자유공간을 확보하는 방법론 이지만, 작업효율이 좋지 않다. (위의 메모리 현황이 압축을 통해 아래의 그림 처럼 바뀌는 효과를 가질 수 있다)

## 단편화 해결하기 위한 방법(메모리 관리 기법, paging, segmentation)

### 1. 페이징 -> 프로세스는 메모리에 연속적으로 존재해야한다는 제약을 없앰, 내부 단편화 문제

> 페이지: 프로세스를 나눈 논리 단위(Frame과 동일한 크기), 물리 메모리는 Frame이라는 고정된 크기로 분리되어 있음.

하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 **메모리 관리 방법**이다.
외부 단편화와 압축 작업을 해소 하기 위해 생긴 방법론으로, 물리 메모리는 Frame 이라는 고정 크기로 분리되어 있고, 논리 메모리(프로세스가 점유하는)는 페이지라 불리는 고정 크기의 블록으로 분리된다.(페이지 교체 알고리즘에 들어가는 페이지)

단점 : 내부 단편화 문제의 비중이 늘어나게 된다.

### 2. Segmentation(세그멘테이션) ->

페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적 단위인 세그먼트(Segment)로 분할
사용자가 두 개의 주소로 지정(세그먼트 번호 + 변위) **세그먼트 테이블**에는 각 세그먼트의 기준(세그먼트의 시작 물리 주소)과 한계(세그먼트의 길이)를 저장

단점 : 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 자유 공간들이 많은 수의 작은 조각들로 나누어져 못 쓰게 될 수도 있다.(외부 단편화)

### 가상메모리 -> 페이지로 관리

다중 프로그래밍을 실현하기 위해서는 많은 프로세스들을 동시에 메모리에 올려두어야 한다.
가상메모리는 **프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법** 이며, 프로그램이 물리 메모리보다 커도 된다는 주요 장점이 있다.

#### 프로그램의 일부분만 메모리에 올릴 수 있다면...

- 물리 메모리 크기에 제약받지 않게 된다.
- 더 많은 프로그램을 동시에 실행할 수 있게 된다. 이에 따라 `응답시간`은 유지되고, `CPU 이용률`과 `처리율`은 높아진다. -> swap이 적어지면 context switching도 적어지고, cpu가 하는 일도 줄어든다.
- [swap](https://github.com/jbee37142/Interview_Question_for_Beginner/tree/main/OS#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EB%B0%B0%EA%B2%BD)에 필요한 입출력이 줄어들기 때문에 프로그램들이 빠르게 실행된다.

### 가상 메모리가 하는 일 -> 작은 메모리 공간으로도 큰 프로세스를 실행시킬 수 있다

가상 메모리는 실제의 **물리 메모리 개념**과 사용자의 **논리 메모리 개념을 분리**한 것으로 정리할 수 있다. 이로써 **작은 메모리**를 가지고도 얼마든지 **큰 `가상 주소 공간`을 프로그래머에게 제공**할 수 있다.

#### 가상 주소 공간

- 한 프로세스가 메모리에 저장되는 논리적인 모습을 가상메모리에 구현한 공간이다. 프로세스가 요구하는 메모리 공간을 가상메모리에서 제공함으로써 **현재 직접적으로 필요치 않은 메모리 공간**은 실제 **물리 메모리에 올리지 않는 것**으로 물리 메모리를 절약할 수 있다.
- 예를 들어, 한 프로그램이 실행되며 논리 메모리로 100KB 가 요구되었다고 하자. 하지만 실행까지에 필요한 메모리 공간`(Heap영역, Stack 영역, 코드, 데이터)`의 합이 40KB 라면, 실제 물리 메모리에는 40KB 만 올라가 있고, 나머지 60KB 만큼은 필요시에 물리메모리에 요구한다고 이해할 수 있겠다.

### 페이지 교체 -> 물리 메모리가 다 찻을 경우 어떤페이지를 교체할 것인지

1. FIFO(큐)
   - 먼저 물리 메모리에 들어온 페이지 순서대로 페이지 교체 시점에 먼저 나가게 된다는 것이다.
2. 최적 페이지 교체(Optimal Page Replacement) -> 미래에 가장 오랫동안 사용되지 않을 페이지
   - `앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체`하는 것이다. 주로 비교 연구 목적을 위해 사용한다.
3. LRU 페이지 교체( Least-Recently-Used) -> 과거에 가장 오랫동안 사용되지 않았던거
   - 최적 알고리즘의 근사 알고리즘으로, 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다.
4. LFU(Least Frequently Used Page Replacement)
   - 참조 횟수가 가장 적은 페이지를 교체하는 방법이다. 활발하게 사용되는 페이지는 참조 횟수가 많아질 거라는 가정에서 만들어진 알고리즘이다.
5. MFU(Most Frequentyl Used Page Replacement)
   - 참조 회수가 가장 작은 페이지가 최근에 메모리에 올라왔고, 앞으로 계속 사용될 것이라는 가정에 기반한다.
   - 특징: 최적(OPT) 페이지 교체를 제대로 근사하지 못하기 때문에, 잘 쓰이지 않는다.
