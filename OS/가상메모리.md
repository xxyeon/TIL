## 메모리 관리 전략

> 가상 메모리는 메모리 관리 기법 중 하나로 컴퓨터가 실제로 이용가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것을 말한다.

### 페이지 폴트(Page Fault)

> 프로세스의 주소 공간(가상 주소 공간)에는 존재하는데, 실제 RAM에 없는 데이터에 접근했을 때 발생한다.

페이지 폴트로 인한 Swapping 과정은 다음과 같다.

1. 프로세스가 주소공간의 특정 위치에 접근하기 위해 가상 주소를 만들어내면 가상 주소를 변환하기위해 주소에 해당하는 페이지를 위한 페이지 테이블 항목에 접근
2. 가상 주소가 해당 페이지에 대한 첫번재 참조인 경우 (해당 페이지가 메모리에 로드되어 있지 않은 경우) 에는 해당 페이지 테이블 엔트리의 valid bit가 invalid로 되어 있을 것이고 trap이 발생한다. trap이 발생하면 운영체제 내에 페이지 fault를 처리하는 함수로 제어가 이동한다.
3. 해당 페이지를 디스크로 부터 찾게 된다. 이 단계부터는 운영체제 커널의 페이지 fault 처리함수의 동작에 해당하고 ,1번과 2번은 sw적인 과정이 아니라 MMU가 수행하는 하드웨어 동작이다
4. 페이지를 찾아서 메인 메모리로부터 빈 frame을 확보한 후에 디스크로 부터 찾은 페이지를 빈 frame으로 읽어들인다.
5. 페이지 fault가 발생했던 해당 페이지가 메인 메모리에 위치하게 되었으므로 해당 정보를 페이지 테이블 항목에 반영한다. → invalid로 되어잇던 페이지 테이블의 엔트리 값은 valid로 변경
6. 페이지 fault가 발생했을 때 그 fault를 일으킨 cpu의 명령을 다시 실행을 한다. 일반적으로 page fault는 명령을 실행하는 단계에서 명령 내에서 메모리를 접근할때 발생 (명령 실행중에 fault가 발생했기 때문에 명령의 실행이 중단되었던 상태일것이다. fault를 일으킨 명령을 다시 처음부터 실행한다)

### 단편화는 왜 생기는가?

프로세스가 메모리에 올라갔다가 스케줄러에 의해 다시 보조기억장치로 swapping되는 과정이 반복적으로 일어나면서 메모리 단편화가 생긴다.

- swap-in: 보조 기억 장치 -> ram
- swap-out: ram -> 보조기억 장치

1. 외부 단편화: ~~메모리 공간 중 **사용하지 못하게 되는** 일부분, 물리 메모리 공간들을 모두 합치면 충분한 공간이 되는 부분들이 분산되어 있을 때 발생한다. -> 프로세스가 외부 단편화로 인해 못들어감, 모두 합치면 충분히 들어갈 수 있는데... 사용하지 못함~~  
   메모리를 나눈 크기보다 프로세스가 커서 들어가지 못하여 비는 공간이 생기는 현상(예를 들어서 100MB 메모리를 55MB, 45MB로 나누었지만 프로세스 크기는 70MB일 때 들어가지 못하여 메모리에 남는 공간이 생긴다.)
2. 내부 단편화: ~~**프로세스가 사용하는** 메모리 공간에 포함된 남은 부분~~  
   메모리를 나눈 크기보다 프로세스가 작아서 들어가지 못하는 혀상

압축 : 외부 단편화를 해소하기 위해 프로세스가 사용하는 공간들을 한쪽으로 몰아, 자유공간을 확보하는 방법론 이지만, 작업효율이 좋지 않다. (위의 메모리 현황이 압축을 통해 아래의 그림 처럼 바뀌는 효과를 가질 수 있다)축 : 외부 단편화를 해소하기 위해 프로세스가 사용하는 공간들을 한쪽으로 몰아, 자유공간을 확보하는 방법론 이지만, 작업효율이 좋지 않다. (위의 메모리 현황이 압축을 통해 아래의 그림 처럼 바뀌는 효과를 가질 수 있다)

## 단편화 해결하기 위한 방법(메모리 관리 기법, paging, segmentation)

### 1. 페이징 -> 프로세스는 메모리에 연속적으로 존재해야한다는 제약을 없앰, 내부 단편화 문제

> 페이지: 프로세스를 나눈 논리 단위(Frame과 동일한 크기), 물리 메모리는 Frame이라는 고정된 크기로 분리되어 있음.

하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 **메모리 관리 방법**이다.
외부 단편화와 압축 작업을 해소 하기 위해 생긴 방법론으로, 물리 메모리는 Frame 이라는 고정 크기로 분리되어 있고, 논리 메모리(프로세스가 점유하는)는 페이지라 불리는 고정 크기의 블록으로 분리된다.(페이지 교체 알고리즘에 들어가는 페이지)

단점 : 내부 단편화 문제의 비중이 늘어나게 된다.

### 2. Segmentation(세그멘테이션) ->

페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적 단위인 세그먼트(Segment)로 분할
사용자가 두 개의 주소로 지정(세그먼트 번호 + 변위) **세그먼트 테이블**에는 각 세그먼트의 기준(세그먼트의 시작 물리 주소)과 한계(세그먼트의 길이)를 저장

단점 : 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 자유 공간들이 많은 수의 작은 조각들로 나누어져 못 쓰게 될 수도 있다.(외부 단편화)

### 가상메모리 -> 페이지로 관리

다중 프로그래밍을 실현하기 위해서는 많은 프로세스들을 동시에 메모리에 올려두어야 한다.
가상메모리는 **프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법** 이며, 프로그램이 물리 메모리보다 커도 된다는 주요 장점이 있다.

#### 프로그램의 일부분만 메모리에 올릴 수 있다면...

- 물리 메모리 크기에 제약받지 않게 된다.
- 더 많은 프로그램을 동시에 실행할 수 있게 된다. 이에 따라 `응답시간`은 유지되고, `CPU 이용률`과 `처리율`은 높아진다. -> swap이 적어지면 context switching도 적어지고, cpu가 하는 일도 줄어든다.
- [swap](https://github.com/jbee37142/Interview_Question_for_Beginner/tree/main/OS#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EB%B0%B0%EA%B2%BD)에 필요한 입출력이 줄어들기 때문에 프로그램들이 빠르게 실행된다.

### 가상 메모리가 하는 일 -> 작은 메모리 공간으로도 큰 프로세스를 실행시킬 수 있다

가상 메모리는 실제의 **물리 메모리 개념**과 사용자의 **논리 메모리 개념을 분리**한 것으로 정리할 수 있다. 이로써 **작은 메모리**를 가지고도 얼마든지 **큰 `가상 주소 공간`을 프로그래머에게 제공**할 수 있다.

#### 가상 주소 공간

- 한 프로세스가 메모리에 저장되는 논리적인 모습을 가상메모리에 구현한 공간이다. 프로세스가 요구하는 메모리 공간을 가상메모리에서 제공함으로써 **현재 직접적으로 필요치 않은 메모리 공간**은 실제 **물리 메모리에 올리지 않는 것**으로 물리 메모리를 절약할 수 있다.
- 예를 들어, 한 프로그램이 실행되며 논리 메모리로 100KB 가 요구되었다고 하자. 하지만 실행까지에 필요한 메모리 공간`(Heap영역, Stack 영역, 코드, 데이터)`의 합이 40KB 라면, 실제 물리 메모리에는 40KB 만 올라가 있고, 나머지 60KB 만큼은 필요시에 물리메모리에 요구한다고 이해할 수 있겠다.

### 페이지 교체 -> 물리 메모리가 다 찻을 경우 어떤페이지를 교체할 것인지

1. FIFO(큐)
   - 먼저 물리 메모리에 들어온 페이지 순서대로 페이지 교체 시점에 먼저 나가게 된다는 것이다.
2. 최적 페이지 교체(Optimal Page Replacement) -> 미래에 가장 오랫동안 사용되지 않을 페이지
   - `앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체`하는 것이다. 주로 비교 연구 목적을 위해 사용한다.
3. LRU 페이지 교체( Least-Recently-Used) -> 과거에 가장 오랫동안 사용되지 않았던거
   - 최적 알고리즘의 근사 알고리즘으로, 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다.
4. LFU(Least Frequently Used Page Replacement)
   - 참조 횟수가 가장 적은 페이지를 교체하는 방법이다. 활발하게 사용되는 페이지는 참조 횟수가 많아질 거라는 가정에서 만들어진 알고리즘이다.
5. MFU(Most Frequentyl Used Page Replacement)
   - 참조 회수가 가장 작은 페이지가 최근에 메모리에 올라왔고, 앞으로 계속 사용될 것이라는 가정에 기반한다.
   - 특징: 최적(OPT) 페이지 교체를 제대로 근사하지 못하기 때문에, 잘 쓰이지 않는다.
