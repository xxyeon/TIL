## 프로토콜이란?

컴퓨터간 데이터 통신을 원활히 하기 위한 통신 규약이다. 신호 송신의 순서(handshaking) 나 데이터 표현법, 오류 검출법 등을 정한 것이다.

## HTTP 프로토콜이란?

Hypertext Transfer Protocol의 약자로, 하이버텍스트를 전송하기 위한 통신 규약이다.
하이퍼텍스트: 참조(하이퍼링크)를 통해 독자가 한 문서에서 다른 문서로 즉시 접근할 수 있는 텍스트이다.
비연결성 프로토콜, Requst에 대한 response만 전달되고 연결은 유지되진 않는다.

## 비연결성을 해결하기 위한 방법

> HTTP는 요청간 연결을 유지하지 않는 프로토콜이다. 즉, 클라이언트가 어떤 사용자였는지 서버는 매번 기억하지 못해서 "로그인 유지" 같은 상태 유지 기능이 필요할 때, 쿠키, 세션을 통해 클라이언트를 식별하고 상태를 유지한다.

1. Cookie/Session(stateful): Cookie에 클라이언트에 대한 정보를 저장했다가 사용거나, Session에 사용자 정보를 저장해서 유지하는 방식
2. Session Storage / Local Storage

- Session Storage: HTML5에서 제공, 세션 스토리지는 세션이 유지되고 있을 때까지 브라우저 내부 저장소에 저장하고 세션이 끊기면 자동으로 없어진다.
- Local Storage: 사용자나 프론트엔드 내부적으로 삭제를 하지 않는 이상 영구적으로 저장된다.

## HTTPS 프로토콜이란

HTTP + SSL, HTTP 통신하는 소켓을 SSL(Secure Socket Layer) or TLS(Transport Layer Security) 라는 프로토콜로 대체하는 것(새로운 별개의 프로토콜이 아니라 연결 방식이 달라진 것이다)
HTTP는 TCP와 직접 통신하지만, HTTPS에서는 SSL과 통신하고 SSL이 TCP와 통신하는 방식
대칭키 암호화 방식과 공개키 암호화 방식을 혼합한 하이브리드 암호 시스템 사용, 공개키를 공개키 암호와 방식으로 교환하고 이후 통신은 대칭키 암호를 사용하는 방식

### 자세한 설명

1. 서버가 공개키/개인키 쌍를 생성하여 CA에게 공개키를 제출하고 인증서를 발급받는다
2. 클라이언트가 https 로 접속을 하면 서버는 인증서를 보내고, 클라이언트는 이 인증서가 신뢰할 수 있는 CA에 의해 서명되었는지 검증한다.
   > (인증서 안에 있는 서버의 공개키는 내용물일 뿐 CA에 의해 서면된 인증서를 검증하면 됨.)
3. 서버의 공개키를 획득하여 세션키(대칭키)를 공개키로 암호화하고 이를 서버에게 전달
4. 서버는 자신의 개인키를 사용해 암호화된 세션키를 복호화하여 대칭키를 얻는다.
5. 이후에는 이 대칭키(세션키)를 이용해 데이터를 빠르게 암호화/복호화하며 통신한다.

## HTTP Request - GET 과 POST의 차이점

- GET: 서버에 데이터를 전달할 때 URL Query를 사용해야 하므로 보안에 취약함 / 데이터를 받는 용도로 적합
- POST: 데이터를 Body에 넣어서 전송하므로 body를 열어보지 않으면 확인할 수 없다 / DB내용을 갱신하거나 서버로 데이터를 전송할 때 적합
- SSL 을 이용한 HTTPS 프로토콜로 데이터 전송을 암호화하면 보안성을 보완할 수 있다. URL 뒤에 붙는 쿼리스트링 내용 모두 암호화되어 전송되기 때문에 보안성을 강화함

## Restful API 에서의 URL과 일반적인 HTTP에서의 URL의 차이는?

- 일반적인 HTTP URL은 기능에 중심을 두고 설계하고
- Restful API는 리소스에 중점을 두고 설계한다. 슬래시("/")를 사용하여 하위 관계를 표현하고 POST, GET, PUT, PARCH, DELETE HTTP 메서드를 사용한다.

## TCP/UDP 포트 목록

> IANA(Internet Assigned Numbers Authority)는 인터넷 할당 번호 관리기관의 약자로 IP 주소, 최상위 도메인 등을 관리하는 단체이다

잘 알려진 포트(well-known port)는 특정한 쓰임새를 위해서 IANA에서 할당한 TCP 및 UDP 포트 번호의 일부이다. 일반적으로 포트 번호는 다음과 같이 세 가지로 나눌 수 있다.

- 0번 ~ 1023번: 잘 알려진 포트 (well-known port)
- 1024번 ~ 49151번: 등록된 포트 (registered port)
- 49152번 ~ 65535번: 동적 포트 (dynamic port)

| 프로토콜 | 포트   | 설명                                                                                                                                  |
| -------- | ------ | ------------------------------------------------------------------------------------------------------------------------------------- |
| HTTP     | 80     | 웹을 지원하기 위한 프로토콜로, GET, PUT같은 프로토콜 기능을 포함해서 웹 서버에게 어떠한 content를 요청하고 또는 웹 서버로 정보를 꺼냄 |
| FTP      | 20, 21 | TCP를 활용해 대량의 파일을 송신하고 수신하는 프로토콜                                                                                 |
| TFTP     | 69     | UDP를 사용하는 파일 전송 프로토콜, 라우터나 스위치 등의 네트워크 장비의 IOS 이미지를 업로드, 다운로드 할 때 사용                      |
| Telenet  | 23     | 원격지에 있는 장비로 표준 터미널 에뮬레이션 기능을 제공함. 네트워크 장비에서는 텔넷을 통해 원격지에서 장비를 설정                     |
| SMTP     | 25     | 컴퓨터 네트워크를 통해 전자메일을 전송하는 프로토콜, 받을 때는 POP3를 활용                                                            |
| SNMP     | 161    | 네트워크 장비를 모니터링하고 제어하기 위해 사용하는 프로토콜로 네트워크 장애 관리, 장비 설정, 통계 성능 및 보안 등을 관리             |
| DNS      | 53     | 도메인 주소를 IP Address로 변경, 모든 퍼블릭 IP 주소화 호스트 이름은 DNS에 저장되고 나중에 IP 주소로 변환                             |

## 웹 통신의 큰 흐름: https://www.google.com/ 을 접속할 때 일어나는 일

면접 단골 문제입니다. 면접관 입장에서는 한 질문으로 많은 답변을 들을 수 있기 때문에 대부분의 면접자리에서 나왔던 문제입니다. OSI 7계층과도 연관지어 설명하라는 질문을 받은적도 있습니다.

브라우저가 URL에 적힌 값을 파싱해서 HTTP Request Message를 만들고, OS에 전송 요청을 합니다. 이 때, Domain으로 요청을 보낼 수 없기 때문에 DNS Lookup을 수행합니다.

DNS 룩업 과정은 크롬의 경우 브라우저 → hosts 파일 → DNS Cache의 순서로 도메인에 매칭되는 ip를 찾습니다. 일반적으로 설명하는 DNS Lookup은 루트 도메인서버에서부터 서브도메인 서버순으로 찾게됩니다.

이 요청은 프로토콜 스택이라는 OS에 내장된 네트워크 제어용 소프트웨어에 의해 패킷에 담기고 패킷에 제어정보를 덧붙여 LAN 어댑터에 전송하고, LAN 어댑터는 이를 전기신호로 변환시켜 송출합니다.

패킷은 스위칭 허브 등을 경유하여 인터넷 접속용 라우터에서 ISP로 전달되고 인터넷으로 이동합니다.
액세스 회선에 의해 통신사용 라우터로 운반되고 인터넷의 핵심부로 전달됩니다. 고속 라우터들 사이로 목적지까지 패킷이 흘러들어가게 됩니다.

핵심부를 통과한 패킷은 목적지의 LAN에 도착하고, 방화벽이 패킷을 검사한 후 캐시 서버로 보내어 웹 서버에 갈 필요가 있는지 검사합니다.

웹 서버에 도착한 패킷은 프로토콜 스택이 패킷을 추출하여 메시지를 복원하고 웹 서버 애플리케이션에 넘깁니다. 애플리케이션은 요청에 대한 응답 데이터를 작성하여 클라이언트로 회송하고, 이는 전달된 방식 그대로 전송됩니다.
