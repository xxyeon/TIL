## 트랜잭션

부분 업데이트 현상이 발생하지 않게 만들어주는 기능
데이터 정합성을 보장하기 위한 기능
락은 MySQL서버의 동시성 문제를 해결하기 위한 도구이고, 트랜잭션은 데이터 정합성을 보장하기 위한 기능이다. 여기서 격리수준은 트랜잭션 간 작업 내용을 어떻게 공유하고 차단할 것인지 결정하는 레벨을 의미한다.

트랜잭션은 디비 커넥션과 동일하게 최소한의 범위에서만 적용해라. 커넥션풀에 커넥션은 제한되어 있고, 커넥션의 범위가 크면 커넥션을 반납하는 시간도 오래걸린ㄷ. -> 많은 요청을 처리할 커넥션이 부족해주고 결국 애플리케이션이 느려진다.

외부 네트워크를 사용하는 로직이 있다면 트랜잭션을 분리하자. 외부 네트워크에서 어떤 문제가 생긴다면 트랜잭션은 거기에 계속 묶어있게 된다. -> DMBS 서버까지 위험한 상항이 발생할 수 있다.

## MySQL엔진 잠금

전역적으로 적용되는 잠금이다. 모든 스토리 엔진에 영향을 미친다. 하지만 스토리 엔진 잠금은 각각 스토리 엔진에 독립적으로 적용된다.

### 글로벌 락

MySQL에서 제공하는 락 중 가장 범위가 크다. 한 세션에서 글로벌 락을 획득하면 다른 세션에서 select을 제외한 DDL, DML을 실행하지 못한다.  
`FLUSH TABLES WITH READ LOCK` 명령으로 획득할 수 있다.  
글로벌 락이 영향을 미치는 범위는 MySQL 서버 전체이고, 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향을 미친다.

이 락은 MySQL의 모든 서버 동작을 멈추게 한다. InnoDB 스토리 엔진 사용이 일반화 되면서 트랜잭션 덕분에 모든 데이터 변경 작업을 멈출 필요가 없어졌다. (트랜잭션으로 데이터 정합성을 맞출 수 있으므로) 그래서 조금 더 가벼운 글로벌 락이 필요해졌다.  
그래서 MySQL 8.0 버전부터 Xtrabackup이나 Enterprise Backup 과 같은 백업 툴들의 안정적인 실행을 위해 백업 락이 도입됐다.

백업락은 일반적인 테이블의 데이터 변경은 허용된다.  
일반적인 MySQL 서버의 구성은 소스 서버, 레플리카 서버로 구성되는데, 백업은 레플리카 서버에서 실행된다. 백업이 `FLUSH TABLES WITH READ LOCK` 명령으로 글로벌 락 획득후 MySQL 서버 전체를 멈추고 실행하면 복제(레플리카로 복제)는 백업(레플리카 서버에서 일어남) 시간 만큼 지연될 수 밖에 없다. 레플리카 서버에서 백업을 실행하는 도중에 소스 서버에 문제가 생기면 레플리카 서버의 데이터가 최신 상태가 될때까지 서비스를 멈추어야할 수도 있다.  
백업 실행 중 DDL 명령하나로 백업이 중단되면, 다시 그 양만큼 다시 백업을 해야한다. MySQL 서버의 백업 락은 이런 목적으로 도입되었고, 정상적으로 복제는 실행되지만 백업의 실패를 막기 위해 DDL 명령이 실행되면 복제(소스 -> 레플리카)를 일시 중지하는 역할을 한다.  
그럼 백업락은 레플리카 서버에서 사용하는 것인가?

### 테이블 락

개별 테이블 전체에 락을 거는 것을 말한다. InnoDB 테이블의 경우 스토리 엔진 차원에서 레코드 기반의 잠금을 제공하므로, 단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지 않는다. 더 정확히는 InnoDB 테이블에도 테이블 락이 설정되지만 대부분의 데이터 변경(DML) 쿼리에서는 무시되고 스키마를 변경하는 쿼리(DDL)의 경우에만 영향을 미친다.

### 네임드 락

네임드 락은 GET_Lock() 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다. 사용자가 문자열을 락으로 활용하여, 문자열을 획득과 반환으로 락 매커니즘을 구현한 것이다.  
잘 사용도지 않고, 예를 들어서, 데이터베이스 서버 1대에 5대의 웹 서버가 접속해서 서비스하는 상황에서 5대의 웹 서버가 어떤 정보를 동기화해야하는 요건처럼 어려 클라이언트가 상호 동기처리해야 할 때 네임드 락을 이용하면 쉽게 해결할 수 있다.

```SQL
-- // 이미 잠금을 사용 중이면 2초 동안만 대기한다. (2초 이후 자동 잠금 해제됨)
SELECT GET_LOCK('mylock1', 2);
```

### 메타데이터 락

데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다.
실시간으로 테이블을 바꿔야하는 요건이 배치 프로그램에서 자주 발생

```SQL
RENAME TABLE rand TO rank_backup, rank_new TO rank;
```

이처럼 실행하면 Table not found 'rank'"오류가 나지 않는다.

기존 테이블의 값을 새로운 테이블에 복제하기 위해 DDL 문법을 사용하는데, 서버의 DDL은 단일 스레드로 동작하기 때문에 시간이 많이 소모된다. 새로운 구조의 테이블을 먼저 만들고 최근의 데이터까지는 프라이머리 키인 id 값을 범위별로 나눠서 여러 개의 스레드로 빠르게 복사하는 방법이 있다.  
나머지 데이터는 트랜잭션과 테이블 잠금, RENAME TABLE 명령으로 응용 프로그램의 중단 없이 실행할 수 있다.

# InnoDB 스토리 엔진 잠금

## 레코드락

레코드 자체만을 잠그는 것을 레코드 락이라고 하며, 다른 사용 DBMS의 레코드 락과 동일한 역할을 한다.  
가장 중요한 차이는 InnoDB 스토리 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다는 점이다.
자동 생성되는 클러스터 인덱스를 이용해서 잠금을 설정한다.  
InnoDB는 대붑분 보조 인덱스를 이용한 변경 작업은 넥스트 키 락 또는 갭락을 사용하지만 프라이머리 키 또는 유니크 인덱스에 의한 변경 작업에서는 갭에 대해서는 잡그지 않고 레코드 자체에 대해서만 락을 건다.

## 갭락

다른 DBMS 다른 점인 갭락이다. 갭락은 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다. 갭 락의 역할을 레코드와 레코드 사이에 새로운 레코드가 생성되는 것을 제어하는 것이다.

## 넥스트 키 락

레코드 락과 갭락을 합쳐놓은 형태의 잠금을 넥스트 키 락이라고 한다. REPEATABLE READ 격리 수준을 사용해야한다.  
InnoDB의 갭락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다.
