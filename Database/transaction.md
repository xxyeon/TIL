## 트랜잭션

부분 업데이트 현상이 발생하지 않게 만들어주는 기능
데이터 정합성을 보장하기 위한 기능
락은 MySQL서버의 동시성 문제를 해결하기 위한 도구이고, 트랜잭션은 데이터 정합성을 보장하기 위한 기능이다. 여기서 격리수준은 트랜잭션 간 작업 내용을 어떻게 공유하고 차단할 것인지 결정하는 레벨을 의미한다.

트랜잭션은 디비 커넥션과 동일하게 최소한의 범위에서만 적용해라. 커넥션풀에 커넥션은 제한되어 있고, 커넥션의 범위가 크면 커넥션을 반납하는 시간도 오래걸린ㄷ. -> 많은 요청을 처리할 커넥션이 부족해주고 결국 애플리케이션이 느려진다.

외부 네트워크를 사용하는 로직이 있다면 트랜잭션을 분리하자. 외부 네트워크에서 어떤 문제가 생긴다면 트랜잭션은 거기에 계속 묶어있게 된다. -> DMBS 서버까지 위험한 상항이 발생할 수 있다.

## MySQL엔진 잠금

전역적으로 적용되는 잠금이다. 모든 스토리 엔진에 영향을 미친다. 하지만 스토리 엔진 잠금은 각각 스토리 엔진에 독립적으로 적용된다.

### 글로벌 락

MySQL에서 제공하는 락 중 가장 범위가 크다. 한 세션에서 글로벌 락을 획득하면 다른 세션에서 select을 제외한 DDL, DML을 실행하지 못한다.  
`FLUSH TABLES WITH READ LOCK` 명령으로 획득할 수 있다.  
글로벌 락이 영향을 미치는 범위는 MySQL 서버 전체이고, 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향을 미친다.

이 락은 MySQL의 모든 서버 동작을 멈추게 한다. InnoDB 스토리 엔진 사용이 일반화 되면서 트랜잭션 덕분에 모든 데이터 변경 작업을 멈출 필요가 없어졌다. (트랜잭션으로 데이터 정합성을 맞출 수 있으므로) 그래서 조금 더 가벼운 글로벌 락이 필요해졌다.  
그래서 MySQL 8.0 버전부터 Xtrabackup이나 Enterprise Backup 과 같은 백업 툴들의 안정적인 실행을 위해 백업 락이 도입됐다.

백업락은 일반적인 테이블의 데이터 변경은 허용된다.  
일반적인 MySQL 서버의 구성은 소스 서버, 레플리카 서버로 구성되는데, 백업은 레플리카 서버에서 실행된다. 백업이 `FLUSH TABLES WITH READ LOCK` 명령으로 글로벌 락 획득후 MySQL 서버 전체를 멈추고 실행하면 복제(레플리카로 복제)는 백업(레플리카 서버에서 일어남) 시간 만큼 지연될 수 밖에 없다. 레플리카 서버에서 백업을 실행하는 도중에 소스 서버에 문제가 생기면 레플리카 서버의 데이터가 최신 상태가 될때까지 서비스를 멈추어야할 수도 있다.  
백업 실행 중 DDL 명령하나로 백업이 중단되면, 다시 그 양만큼 다시 백업을 해야한다. MySQL 서버의 백업 락은 이런 목적으로 도입되었고, 정상적으로 복제는 실행되지만 백업의 실패를 막기 위해 DDL 명령이 실행되면 복제(소스 -> 레플리카)를 일시 중지하는 역할을 한다.  
그럼 백업락은 레플리카 서버에서 사용하는 것인가?

### 테이블 락

개별 테이블 전체에 락을 거는 것을 말한다. InnoDB 테이블의 경우 스토리 엔진 차원에서 레코드 기반의 잠금을 제공하므로, 단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지 않는다. 더 정확히는 InnoDB 테이블에도 테이블 락이 설정되지만 대부분의 데이터 변경(DML) 쿼리에서는 무시되고 스키마를 변경하는 쿼리(DDL)의 경우에만 영향을 미친다.

### 네임드 락

네임드 락은 GET_Lock() 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다. 사용자가 문자열을 락으로 활용하여, 문자열을 획득과 반환으로 락 매커니즘을 구현한 것이다.  
잘 사용도지 않고, 예를 들어서, 데이터베이스 서버 1대에 5대의 웹 서버가 접속해서 서비스하는 상황에서 5대의 웹 서버가 어떤 정보를 동기화해야하는 요건처럼 어려 클라이언트가 상호 동기처리해야 할 때 네임드 락을 이용하면 쉽게 해결할 수 있다.

```SQL
-- // 이미 잠금을 사용 중이면 2초 동안만 대기한다. (2초 이후 자동 잠금 해제됨)
SELECT GET_LOCK('mylock1', 2);
```

### 메타데이터 락

데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다.
실시간으로 테이블을 바꿔야하는 요건이 배치 프로그램에서 자주 발생

```SQL
RENAME TABLE rand TO rank_backup, rank_new TO rank;
```

이처럼 실행하면 Table not found 'rank'"오류가 나지 않는다.

기존 테이블의 값을 새로운 테이블에 복제하기 위해 DDL 문법을 사용하는데, 서버의 DDL은 단일 스레드로 동작하기 때문에 시간이 많이 소모된다. 새로운 구조의 테이블을 먼저 만들고 최근의 데이터까지는 프라이머리 키인 id 값을 범위별로 나눠서 여러 개의 스레드로 빠르게 복사하는 방법이 있다.  
나머지 데이터는 트랜잭션과 테이블 잠금, RENAME TABLE 명령으로 응용 프로그램의 중단 없이 실행할 수 있다.

# InnoDB 스토리 엔진 잠금

## 레코드락

레코드 자체만을 잠그는 것을 레코드 락이라고 하며, 다른 사용 DBMS의 레코드 락과 동일한 역할을 한다.  
가장 중요한 차이는 InnoDB 스토리 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다는 점이다.
자동 생성되는 클러스터 인덱스를 이용해서 잠금을 설정한다.  
InnoDB는 대붑분 보조 인덱스를 이용한 변경 작업은 넥스트 키 락 또는 갭락을 사용하지만 프라이머리 키 또는 유니크 인덱스에 의한 변경 작업에서는 갭에 대해서는 잡그지 않고 레코드 자체에 대해서만 락을 건다.

## 갭락

다른 DBMS 다른 점인 갭락이다. 갭락은 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다. 갭 락의 역할을 레코드와 레코드 사이에 새로운 레코드가 생성되는 것을 제어하는 것이다.

## 넥스트 키 락

레코드 락과 갭락을 합쳐놓은 형태의 잠금을 넥스트 키 락이라고 한다. REPEATABLE READ 격리 수준을 사용해야한다.  
InnoDB의 갭락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다.

## 자동 증가 락

MySQL애서는 자동 증가하는 숫자 값을 추출(채번)하기 위해 `AUTO_INCREMENT`라는 칼럼 속성을 제공한다.
InnoDB 스토리 엔진에서는 내부적으로 `AUTO_INCREMENT` 락 이라고도 하는 테이블 수준의 잠금을 사용한다.  
해당 락은 Insert나 Replace 쿼리 문장과 같이 새로운 레코드를 저장하는 쿼리에서만 필요하고, Update, Delete 등에는 걸리지 않는다.
`AUTO_INCREMENT` 락은 트랜잭션과 상관없이 Insert나 Replace 문장에서 `AUTO_INCREMENT` 값을 가져오는 순간만 락이 걸렸다가 해체되므로 문제가 되지 않는다.
MySQL 5.0 버전 이하에서는 해당 락 작동 방식에 대해 커스텀할 수 없었는데, MySQL 5.1 이상부터는 `innodb_autoinc_lock_model` 라는 시스템 변수를 사용해서 자동 증가 락의 작동 방식을 변경할 수 있다.

## 인덱스와 잠금

위에서 말한 레코드 락이 InnoDB 스토리 엔진에서는 인덱스락으로 걸린다고 하였다. 인덱스로 설정된 first_name이 있다고 하고, where fisrt_name = '지연' and last_name = '김' 조건인 쿼리를 실행한다고 했을 때, first_name = '김'인 인덱스에 모두 Lock이 걸리게 된다. 실제로 조호하려는 레코드가 1개 뿐이라도 검색하려는 인덱스에 걸린 값이 여러개라면 해당하는 인덱스 모두에게 락을 걸게 된다.  
만일 인덱스를 사용하지 않는다면 풀 스캔하면서 update 작업을 하는데, 이 과정에서 풀 스캔에 포함된 레코드 모두가 락이 걸린다.  
이런 이유로 InnoDB 에서 인덱스 설계가 중요한 이유이다.

## MySQL 격리 수준

> 트랜잭션 격리 수준이란 여러 트랜잭션이 동시에 실행될 때 특정 트랜잭션이 다른 트랜잭션이 변경, 조회하는 데이터를 볼 수 있도록 허용하는냐, 안하느냐를 결정하는 것이다.

격리 수준을 어떻게 설정하느냐에 따라 부정합을 보일 수 있다. 부정합은 아래와 같이 3개가 있다.

1. Dirty Read
2. Non-Repeatable Read
3. Phantom Read

### Read Uncommitted

> 아직 커밋하기 전의 변경 내용을 다른 트랜잭션이 읽을 수 있다.

Dirty Read와 Non Repeatable Read, Phantom Read 3개의 부정합 현상이 나타난다.

### Read Committed

> 다른 트랜잭션이 Commit 한 데이터만 읽을 수 있다. Commit 전에는 undo 영역을 읽는다.

Non-Repeatalbe Read와 Phantom Read 부정합 현상이 나타난다.

### Repeatable Read

> 동일한 트랜잭션에서 실행한 동일한 조회 쿼리문에 대해서는 항상 동일한 결과가 나온다. 다른 트랜잭션이 Commit을 했다고 하더라도, 자신의 트랜잭션이 끝나기 전에는 항상 동일한 결과를 조회한다.

Phantom Read가 나타나지만 InnoDB 스토리 엔진에서는 MVCC가 구현되어 있으므로 Repeatable Read 격리수준에서도 Phantom Read가 나타나지 않는다.  
하지만 select ...for update로 쓰기 잡금을 걸고 읽으면 Phantom Read 부정합이 나타난다. 쓰기 잠금은 레코드에 잠금을 거는데, 언두 로그에 잠금을 걸 수 없으므로 실제 레코드 값을 읽으면서 Phantom Read 현상이 나타난다.

InnoDB 스토리 엔진의 기본 트랜잭션 격리 수준이다.
InnoDB 스토린 엔진은 트랜잭션이 Rollback될 가능성에 대비해 변경되기 전 레코드를 언두 공간에 백업해두고 실제 레코드 값을 변경하고, 이런 방식을 MVCC라고 한다. ReadComitted에서 발생하는 NON-REPEATABLE READ 부정합이 발생하지 않는다.  
모든 InnoDB의 트랜잭션은 고유한 트랜잭션 번호를 가지고, 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션 번호가 포함되어 있다.
REPEATABLE READ 격리 수준에서는 MVCC 를 보장하기 위해 실행중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 앞선 언두 영역의 데이터는 삭제할 수가 없다.
현재 실행중인 트랜잭션 id 보다 작은 트랜잭션 id가 변경한 값을 읽는다.

### 언두 로그에 동일한 레코드가 여러 버전이 있다면

하지만 언두 영역에 백업된 레코드의 여러 버전 가운에 몇번째 버전을 찾아 들어가야 하는냐?  
상황이 아래와 같다고 해보자.

```
- 트랜잭션 ID 10이 **트랜잭션 격리 수준이 `REPEATABLE READ`** 로 동작 중.
- 트랜잭션 ID 12가 현재 레코드를 `UPDATE` 해서 최신 레코드의 `trx_id = 12`.
- 해당 레코드에 대해 언두 로그가 존재하고, 언두 로그에 트랜잭션 ID 6, 7의 버전이 있음.
- 트랜잭션 10이 이 레코드를 읽을 때 어떤 언두 버전 읽을까?
```

- 트랜잭션 ID 10이 시작될 때 기준으로, ID 6과 7이 **둘 다 커밋된 상태**이고,
- 현재 레코드는 트랜잭션 12에 의해 변경됐으므로 트랜잭션 10은 최신 버전(12)을 **읽을 수 없음**.
- 따라서 언두 로그 체인을 따라가며 **트랜잭션 10의 스냅샷에 보이는 가장 최신 버전**을 찾게 된다.

- **트랜잭션 ID 7의 버전**이 트랜잭션 10의 스냅샷에 보이고, 커밋된 상태라면 → **ID 7의 버전.**
- 만약 트랜잭션 7이 아직 커밋되지 않았거나 트랜잭션 10 시작 이후에 커밋됐다면 → **ID 6의 버전.**

즉, **가장 최근이면서도 트랜잭션 10 입장에서 "보이는" 커밋된 버전**을 선택한다.

### 상황 예시

```sql
#TxId = 1
START TRANSACTION;
update board set title = '트랜잭션 1' where id=1;
COMMIT ;
```

```sql
#TxId = 2
START TRANSACTION;
update board set title = '트랜잭션 2' where id=1;
COMMIT ;
```

```SQL
#TxId = 3
START TRANSACTION;
select title from board where id = 1;
COMMIT ;
```

```SQL
#TxId = 4
START TRANSACTION;
update board set title = '트랜잭션 4' where id=1;
COMMIT ;
```

상황1) txId = 1과 txId = 2 가 txId=3 시작 전 두개다 커밋 예상 흐름 -> 맞음

1. 트랜잭션1 id = 1 레코드 변경 후 커밋 -> 이전 값 언두 영역에(txId = 1)
2. 트랜잭션2 id = 1 레코드 변경 후 커밋 -> 이전 값 언두 영역(txId = 2)
3. 트랜잭션3 id = 1 조회 -> undo 영역 값 조회(txId=2가 변경한 값)
4. 트랜잭션4 id = 1 레코드 변경 -> 이전 값 언두 영역(txId = 3)
5. 트랜잭션3 id = 1 조회 -> undo 영역 조회(txId=2 변경한 값)
6. 트랜잭션4 커밋
7. 트랜잭션 3 id = 1조회 -> undo 영역 조회 (txId=2)

상황2) txId = 1만txId=3 시작 전 커밋(txId = 2는 txId=3 시작 후 커밋)

1. 트랜잭션1 id = 1 레코드 변경 후 커밋 -> 이전 값 언두 영역에(txId = 1)
2. 트랜잭션2 id = 1 레코드 변경 -> 이전 값 언두 영역(txId = 2)
3. 트랜잭션3 id = 1 조회 -> undo 영역 값 조회(txId=1가 변경한 값) 1
4. 트랜잭션4 id = 1 레코드 변경 -> 이전 값 언두 영역(txId = 3)
5. 트랜잭션2 id = 1 커밋 (해당 레코드가 txId=2로 변경됨
6. 트랜잭션3 id = 1 조회 -> undo 영역 조회(txId=1 변경한 값)? -> 현재 레코드의 txId=2이므로 실제 레코드를 읽나? no 1을 읽는다
7. 트랜잭션4 커밋
8. 트랜잭션 3 id = 1조회 -> undo 영역 조회 (txId=2)

### Serializable

> 가장 엄격한 격리수준으로, 그만큼 동시성도 떨어진다.

InnoDB 테이블에서 순수한 SELECT 작업은 아무런 레코드 잡금도 설정하지 않고 실행된다. InnoDB 메뉴얼의 Non-locking consistent read(잠금이 필요없는 읽기) 라는 말이 이를 의미한다.  
하지만 Serializable 로 설정되면 읽기 작업도 공유 잠금(읽기 잠금, s-lock)을 획득해야하며, 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 된다. 즉, 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서 절대 접근할 수 없다.  
하지만 InnoDB 스토리 엔진에서는 갭락과 넥스트 키 락 덕분에 Repeatable read 격리 수준에서도 이미 Phantom Read가 발생하지 않기 때문에 굳이 Serializable을 사용할 필요성이 없다.  
-> 예외적으로 select ..for update, select .. for share 이렇게 쓰기, 읽기 잠금을 걸로 select 하는 경우는 phantom read현상이 나타남
