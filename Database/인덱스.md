# 데이터베이스 성능

최근에는 자기 디스크 원판에 의존하는 하드디스크보다 SSD 드라이브가 많이 활용되지만, 여진히 데이터 저장 매체는 컴퓨터에서 가장 느린 부분이라는 사실에 변함이 없다.  
성능 이슈는 디스크 I/O를 어떻게 줄이느냐에서 시작. 디스크 I/O는 디스크 드라이브의 플래터(원판)을 돌려서 읽어야할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미
이때 읽는 데 걸리는 시간: 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다.  
즉, 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한번에 기록하느냐에 따라 결정

순차 I/O가 랜덤 I/O보다 빠를 수 밖에 없음.(순차I/O는 헤더를 한번만 움직이면 된다. 연속적인 블록을 읽는 것이므로)  
대부분 작업은 랜덤 I/O이므로 랜던 I/O를 순차 I/O로 바꿔서 실행하기 위해 데이터베이스 쿼리 튜닝을 하는 것이고, 쿼리 튜닝은 랜덤 I/O 자체를 줄여주는 것이 목적이다.  
랜덤 I/O를 줄인다는 것은 쿼리를처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미.

## 인덱스란

데이터를 빠르게 검색하고 관리하기 위한 자료구조
데이터가 책의 내용, 데이터가 저장된 레코드의 주소가 페이지 번호라고 생각하면 된다

### 인덱스를 사용하면서 낮아지는 성능에는 어떤것이 있을까

인덱스는 항상 정렬된 상태를 유지하므로 값을 탐색하는 데엔 빠르지만, 추가, 수정, 삭제하는 경우 쿼리문 실행 속도가 느려진다.
where 조건절에 들어가는 모든 칼럼은 전부 인덱싱하면 데이터 저장 성능이 떨어지고, 인덱스 크기가 비대해져서 역효과

## 인덱스 타입

1. 정렬 인덱스: 조회하려는 키가 정렬되어 있다.
2. 해시 인덱스: 조회하려는 키가 해시 함수를 사용해서 버킷 전체에 균일하게 분산된다.

## 정렬 해시

인덱스 파일이 정렬되고 인덱스 파일에는 레코드의 위치를 저장하고 있어서 인덱스 파일을 통해 레코드에 접근한다.

## 해싱 인덱스

## 키

1. 슈퍼키: 유일성 만족
2. 후보키: 유일성 최소성 만족
3. 대체키: 유실성 최소성 만족하지만 기본키로 선정되지 않은 키: 유일성가 최소성을 만족시키는 키로, 후보키에서 선택된 키

# 인덱스 자료구조

## 1. 이진 트리와 B- 트리(B트리)

### 이진 트리

자식 노드가 2개인 트리

### B-트리

B-Tree는 데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘.
인덱스 구조체 내에서 항상 정렬된 상태를 유지한다.
이진 트리를 확장해 하나의 부모 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조이다.  
균형 잡힌 트리이므로 루트부터 모든 리프의 경로의 길이가 동일하다.  
노드에 키와 데이터를 가지고 있다.  
**구조와 특성**
루트, 브랜치, 리프 노드로 구성되어 있고, 데이터베이스에서 인덱스와 실제 데이터 파일이 따로 관리된다. 리프노트는 항상 실제 데이터 레코드의 주솟값을 가지고 있다.  
인덱스의 키 값은 모두 정렬되어 있지만, 데이터 파일의 레코드는 정렬되어 있지 않다.

> 대부분 RDBMS의 데이터 파일에서 레코드는 특정 기준으로 정렬되지 않고 임의의 순서로 저장된다. InnoDB는 디폴트로 클러스터링 테이블이 생성되므로, InnoDB 테이블에서 레코드는 클러스터드되어 디스크에 저장되므로 기본적으로 PK순으로 정렬되어 저장된다.

### Hash 인덱스 알고리즘

search-key(인덱스로 지정한 칼럼값)로 해시값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다. 하지만 값을 변형해서 인덱싱하므로, 특정 문자로 시작하는 값으로 검색하는 정방일치와 같이 값의 일부만 거색하고자할 때는 해시 인덱스를 사용할 수 없다.  
주로 메모리 기반의 데이터베이스에서 많이 사용한다. -> redis

### B(B-)트리와 B+ 트리(=B+-트리)

| 구분      | B-트리                           | B+트리                                             |
| --------- | -------------------------------- | -------------------------------------------------- |
| 내부 노드 | 키와 값(레코드 주소 또는 데이터) | 키만 저장 (값 없음)                                |
| 리프 노드 | 키와 값                          | 키와 값 (레코드 주소 또는 데이터)                  |
| 값의 위치 | 모든 노드에 존재 가능            | **리프 노드에만 존재**                             |
| 순차 탐색 | 어려움                           | **리프 노드끼리 연결되어 있어서 범위 탐색에 유리** |

#### B+트리

![B+트리 구조 예시](B+tree.png)

키에 의해서 각각 식별되는 레코드의 효율적인 삽입, 검색과 삭제를 통해 정렬된 데이터를 표현하기 위한 트리자료구조의 일종이다.  
B트리와 대조적으로 B+트리는, 모든 레코드(또는 레코드의 주소)들이 리프 노드에 정렬되어있다. internal 노드에 키(search key) 값만 저장된다.  
리프노드의 포인터가 인덱스로 적용된 속성값의 레코드를 가르킨다.  
데이터가 linked list로 연결되어 있어서 range검색에 유용하다.  
![B+트리_리프노드구조.png](B+트리_리프노드구조.png)

## Primary Index vs Secondary Index

### Primary Index

Primary Index는 Primary Key에 대해서 생성된 Index를 의미한다.

- 테이블당 하나의 Primary Index만 존재할 수 있다.

### Secondary Index

Secondary Index는 Primary Key가 아닌 다른 칼럼에 대해서 생성된 Index를 의미한다.

- 테이블당 여러개의 Secondary Index를 생성할 수 있다.

## 클러스터드 인덱스와 논클러스터드 인덱스

### 클러스터드 인덱스

클러스터(Cluster)란 여러 개를 하나로 묶는다는 의미로 주로 사용되는데, 클러스터드 인덱스도 크게 다르지 않다. 인덱스에서 클러스터드는 비슷한 것들을 묶어서 저장하는 형태로 구현되는데, 이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에서 착안된 것이다. 여기서 비슷한 값들은 물리적으로 인접한 장소에 저장 되어 있는 데이터들을 말한다.

클러스터드 인덱스(Clustered Index)는 인덱스가 적용된 속성 값에 의해 레코드의 물리적 저장 위치가 결정되는 인덱스이다.

- 클러스터디 인덱스는 테이블당 하나만 생성할 수 있다.
- 클러스터드 인덱스는 B+ 트리 형태로 구성되어 있다.
- 데이터베이스에서 일반적으로 기본키를 클러스터드 인덱스로 생성한다. (InnoDB 기준)
- 인덱스 페이지가 실제 데이터 페이지를 가지고 있다.
- 인덱스가 적용된 속성 값(주로 Primary Key)에 의해 레코드의 저장 위치가 결정 되며 속성 값이 변경되면 그 레코드의 물리적인 저장 위치 또한 변경되어야 한다.
- 따라서 인덱스 파일만 참조해서 sql query가 가능하다.

### 논클러스터드 인덱스

논클러스터드 인덱스(Non-clustered Index)는 데이터를 물리적으로 정렬하지 않는다.

- 논클러스터드 인덱스는 별도의 인덱스 테이블을 만들어 실제 데이터 테이블의 행을 참조한다.
- 테이블 당 여러 개의 논클러스터드 인덱스를 생성할 수 있다.

## 효율적으로 인덱스 구성하는 방법

- Cardinality: 고유값의 개수
- Selectivity 선택도: 데이터 집합에서 특정 값을 얼마나 잘 골라낼 수 있는가에 대한 지표

```
selectivity - cardinality / total number of records
```

선택도가 1에 가까울 수록 칼럼값들이 유니크하다는 의미 = 인덱스 칼럼으로 최적이라는 의미

## 인덱스를 적용한 테이블에서 Delete와 Update는 어떻게 적용되는가

Delete를하면 실제 파일 레코드가 삭제될지라도, 인덱스 페이지에 있는 row는 삭제되지 않고 삭제된 데이터라고 "표시"만 할 뿐이다.
Update인 경우 기존 인덱스 페이지의 row를 삭제 "표시" 한 후 새로운 row를 만들어낸다.
