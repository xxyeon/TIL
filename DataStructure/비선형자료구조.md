# Tree

트리는 계층적 관계를 표현하는 자료구조이다.

## 트리 구성 요소

노드(node): 트리를 구성하고 있는 각각의 요소를 의미
간선(edge): 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미
루트노드(Root node): 트리 구조에서 최상위에 있는 노드를 의미
리프노트(left node): 하위에 다른 노드가 연결되어 있지 않는 노드
내부노드(internal node): 루트도느를 제외한 모든 노드를 포함

# Binary Tree

루트 노드를 기준으로 두 개의 서브 트리로 나뉘어진다. 서브트리도 이진 트리여야한다.
공집합도 이진트리로 포함해야한다.  
트리에서 각 층별로 숫자를 매겨서 이를 트리의 Level(레벨) 이라고 한다. 레벨의 값은 0부터 시작하고 따라서 루트 노드의 레벨은 0이다.  
그리고 트리의 최고 레벨을 가르켜 해당 트리의 height하고 한다.

## Perfect Binary Tree(포화이진트리), Complete Binary Tree(완전 이진 트리), Full Binary Tree(정 이진트리)

포화이진트리: 모든 레벨이 꽉찬 이진트리
완전이진트리: 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워진 이진트리
정 이진 트리: 모든 노드가 0개 혹은 2개의 자식 노드만을 갖는 이진 트리

## BST(Binary Serch Tree)

시간복잡도: O(log N)
효율적인 탐색을 위한 자료구조로, 아래 규칙을 따른다

1. 이진 탐색 트리의 노드에 저장된 키는 유일하다.
2. 부모의 키가 왼쪽 자식 노드이 키보다 크다.
3. 부모의 키가 오른쪽 자식 노드의 키보다 작다
4. 왼쪽과 오른쪽 서브트리도 이진탐색 트리이다.

트리의 높이를 하나씩 더할 수 록 추가할 수 있는 노드가 두배씩 증가.
편향 트리(Skewed)가 발생하면 O(N)이 될 수도 있다.

## Binary Heap

자료구조의 일종으로 Tree의 형식을 하고 있고, Tree 중에서도 배열에 기반한 Complete Binary Tree이다. 힙에는 최대힙과 최소힙 두 종류가 있다.  
최대 힙이란, 각 노드의 값이 해당 children의 값보다 크거나 같은 complete binary tree를 말한다.
최대 힙에서는 Root node에 있는 값이 제일 크므로, 최대 값을 찾는데 소요되는 시간복잡도가 O(1)이다. 그리고 complete binary tree이기 때문에 배열을 사용하여 효율적으로 관리할 수 있다.(즉, random access가 가능하다). 하지만 heap의 구조를 계속 유지하기 위해서 제건된 루트 노드를 대체할 다른 노드가 필요하다. 여기서 heap은 맨 마지막 노드를 루트노드로 대체시킨 후 다시 heapify 과정을 거쳐 heap구조를 유지한다. 이런 경우 결국 O(log n)의 시간 복잡도로 최대값 또는 최솟값에 접근할 수 있다.

## Red Black Tree

# [Hash Table](https://d2.naver.com/helloworld/831311)

hash는 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 갖는다. 특정한 값을 Search 하는데 데이터 고유의 인덱스로 접근하게 되므로 average case에 대하여 시간복잡도는 O(1)이다.
충돌이 발생할 수 있어서 항상 O(1)은 아니다. 문제는 이 인덱스로 저장되는 key 값이 불규칙하다는 것이다.  
그래서 특별한 알고리즘(해시 함수)을 이용하여 저장할 데이터와 연관된 고유한 숫자를 만들어낸 뒤 이 인텍스를 사용한다. 특정 데이터만의 고유한 위치이기 때문에, 삽입 연산 시 다른 데이터의 사이에 끼어들거나, 삭제 시 다른 데이터로 채울 필요가 없으므로 연상에서 추가적인 비용이 없도록 만들어진 구조이다.

## Hash Function

특별한 알고리즘을 사용하여 고유한 값을 만들어내기 위해 해시 함수를 사용하고, 이 메서드에 의해 반환된 데이터의 고유 값을 hashcode라고 한다.
hash function 을 통해 key값들이 결정된다면 동일한 값이 도출될 수도 있다. 이렇게 되면 key값에 복수개의 데이터가 하나의 테이블에 존재하게 될 것인데 일르 충돌(collision)이라고 한다.  
_collistion_: 서로 다른 두개의 키가 같은 인덱스로 hashing되면 같은 곳에 저장할 수 없게 된다.  
무한한 데이터를 다루는 세상에서 유한한 메모리 공간을 사용하므로 Collision은 필수로 발생하고, 이를 최소화하는 방법으로 설계하는 것이 과제이다.  
Collision이 많아질 수록 Search에 필요한 시간 복잡도가 O(1)에서 O(n)에 가까원진다.
따라서 hashing된 인덱스에 이미 다른 값이 들어있다면 새 데이터를 저장할 다른 위치를 찾은 뒤에야 저장할 수 있다는 것인데, 충돌 해결방법은 아래와 같다.

## 충돌 해결 방법

### 1. Open Address 방법(개방주소법)

> 해시 충돌이 발생하면, 다른 해시 버킷에 해당 자료를 삽입하는 방식이다.

버킷이란 데이터를 저장하기 위한 공간이다. 공개 주소방식이라고도 불리는 이 알고리즘은 Collision이 발생하면 데이터를 저장할 장소를 찾아 헤맨다. Worst Case의 경우 비어있는 버킷을 찾지 못하고 탐색을시작한 위치까지 되돌아 올 수 있다. 비어있는 버킷을 찾기 위한 방법은 3가지가 있다.

1. Linear Probing: 순차적으로 탐색하며 비어있는 버킷을 찾을 때까지 계속 진행한다.
2. Quadratic probing: 2차 함수를 이용해 탐색할 위치를 찾는다.
3. Double hashing probing: 하나의 해시 함수에서 충돌이 발생하면 2차 해시 함수를 이용해 새로운 주소를 할당한다. 위 두가지 방법에 비해 많은 연산량을 요구하게 된다.

### 2. Separate Chaining 방식(분리 연결법)

일반적으로 Open Addressing은 Separate Chaining 보다 느리다. Open Addressing의 경우 해시 버킷을 채운 밀도가 높아질수록 Worst Case 발생 빈도가 더 높아지기 때문이다. 반면 Separate Chaining 방식의 경우 해시 충돌이 잘 발생하지 않도록 보조 해시 함수를 통해 조정할 수 있다면 worst case에 가까워지는 빈도를 줄일 수 있다.  
Java 7 에서는 Separate Chaining 방식을 사용하여 HashMap 을 구현하고 있다. Java8에서는 더 발전된 방식의 Separte Chainig을 사용하고 있다. Separate Chaining 방식으로는 두 가지 구현 방식이 존재한다.

1. 연결 리스트를 사용하는 방식: 각각의 버킷들을 연결 리스트로 만들어 Collision이 발생하면 해당 bucket의 list에 추가하는 방식이다. 연결 리스트의 특징을 그대로 이어받아 삭제 또는 삽입이 간단하다. 하지만 단점도 그대로 물려받아 작은 데이터들을 저장할 때(충돌단 인덱스에 동일한 Node가 있는지 순차탐색) 연결리스트 자체의 오버헤드가 부담이 된다.

2. Tree를 사용하는 방식(Red-Black Tree): Separate Chaining 방식과 동일하며 연결 리스트 대신 트리를 사용하는 방식이다. 연결 리스트를 사용할 것인가와 트리를 사용할 것인가에 대한 기준은 하나의 해시 버킷에 할당된 key-value 쌍의 개수이다. 데이터의 개수가 적다면 링크드 리스트를 사용하는 것이 맞다. 트리는 기본적으로 메모리 사용량이 많기 때문이다. 데이터 개수가 적을 때 Worst Case 를 살펴보면 트리와 링크드 리스트의 성능 상 차이가 거의 없다. 따라서 메모리 측면을 봤을 때 데이터 개수가 적을 때는 링크드 리스트를 사용한다.

### 데이터 개수가 적다는 것은 어떤 기준으로 결정하는가?

링크드 리스트를 사용할 것인가 트리를 사용할 것인가에 대한 기준은 하나의 해시 버킷에 할당된 키-값 쌍의 개수이다. Java 8 HashMap에서는 상수 형태로 기준을 정하고 있다. 즉 하나의 해시 버킷에 8개의 키-값 쌍이 모이면 링크드 리스트를 트리로 변경한다. 만약 해당 버킷에 있는 데이터를 삭제하여 개수가 6개에 이르면 다시 링크드 리스트로 변경한다.  
트리는 링크드 리스트보다 메모리 사용량이 많고, 데이터의 개수가 적을 때 트리와 링크드 리스트의 Worst Case 수행 시간 차이 비교는 의미가 없기 때문이다.  
8과 6으로 2 이상의 차이를 둔 것은, 만약 차이가 1이라면 어떤 한 키-값 쌍이 반복되어 삽입/삭제되는 경우 불필요하게 트리와 링크드 리스트를 변경하는 일이 반복되어 성능 저하가 발생할 수 있기 때문이다.

둘 모두 Worst Case O(M)이다. 하지만 Open Addressing은 연속된 공간에 데이터를 저장하기 때문에 Separate Chaining에 비하여 캐시 효율이 높다. 따라서 데이터 개수가 충분히 적다면 Open Addressing이 Separate Chaining보다 더 성능이 좋다. 하지만 배열의 크기가 커질수록(M 값이 커질수록) 캐시 효율이라는 Open Addressing의 장점은 사라진다. 배열의 크기가 커지면, L1, L2 캐시 적중률(hit ratio)이 낮아지기 때문이다.
