# Array vs LinkedList

## Array

배열은 논리적인 저장 순서와 물리적 저장 순서가 일치한다. 따라서 인덱스로 해당 원소에 접근할 수 있다.  
그렇기 때문에 찾고자하는 원소의 인덱스 값을 알고 있으면 O(1) 시간복잡도를 갖는다. -> random access가 가능하다는 장점이 있다.

삭제, 삽입의 과정에서 해당 원소에 접근하여 작업을 완료한뒤(O(1)) 추가적인 작업이 필요.
삭제의 경우, 배열의 연속적인 특징을 지키키 위해 삭제후 생기는 빈 공간을 메꾸기 위해 shift해줘야 하는 비용이 발생하므로 O(n)이 걸리다.

삽입의 경우, 첫번째 자리에 새로운 원소를 추가한다면 모든 원소들의 인덱스를 1씩 shift 해줘야하므로 이 경우도 O(n)이다.

## LinkedList

배열의 삽입, 삭제 문제를 해결하기 위한 자료구조로, 각각의 원소들은 자기 자신 다음에 어떤 원소가 있는지만을 기억하고 있다. 따라서 이 부분만 다른 값으로 변경하면 삽입, 삭제를 O(1)만에 해결할 수 있다.

원하는 위치에 삽입하고자 한다면 원하는 위치를 serach하는 과정이 있어서 첫번재 원소부터 다 확인해봐야한다. Array와 다르게 논리적인 저장 순서와 물리적인 저장 순서가 일치하지 않기 때문이다.  
이 과정 때문에, 어떠한 원소를 삭제 또는 추가하고자할 때 그 원소를 찾기위해 O(N)의 시간이 추가적으로 발생

#Stac
