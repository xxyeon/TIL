11/10

INSERT 쿼리의 결과를 다시 조회하지 않기 위해서 내부적으로 Statement.getGeneratedKeys를 사용

11/11
Call by ref -> c 언어같은 경우 변수가 메모리를
Call by value -> 자바에서는 이 방법만 사용, 객체가 생성되면 힙에 메모리를 차지하고 해당 메모리의 주소값을 가지게됨. 이 주소값을 변수에 복사해서 전달

11/14

벌크헤드 패턴을 적용해 볼 수 있습니다. 벌크헤드 패턴은 기능의 종류마다 자원 사용을 분리하는 것

자원을 격리하여 서비스 일부에 장애가 발생해도 전체로 전파되지 않도록 보장

외부 서비스마다 다른 HTTP 커넥션 풀을 사용하도록 벌크헤드 패턴을 적용

지속되는 외부 서비스 장애로 타임아웃에 의한 서비스 에러가 발생
이 문제를 해결하기 위해서는 서킷 브레이커를 적용할 수 있는데요. 서킷 브레이커는 오류가 지속되는 경우 일정 시간 동안 기능 실행을 차단할 수 있습니다.

11/16
각 프로세스는 가상메모리로 독립된 공간을 차지, 직접 다름 프로세스 메모리에 잡근하지 않거 네트워크 통신으로 접근
Redis와는 네트워크 소켓(TCP) 통신
localhost여도 TCP로 통신한다.
→ Redis 메모리에 있는 값에 접근할 수 있지만
→ 자바 프로세스 메모리를 직접 읽는 것이 아니다.
인메모리 캐시는 jvm의 힙,메타스페이스 등을 사용하는것임

인메모리 캐시 예시

1. Spring Boot + Caffeine Cache
   Spring의 @Cacheable을 Caffeine으로 설정하면
   Java 애플리케이션 JVM Heap 내부에 캐시가 저장됨.
   ✔ 별도 Redis 없음
   ✔ 네트워크 호출 없음
   ✔ 동일 JVM Heap에 저장 → 서버 프로세스 메모리를 그대로 사용

2. Spring Boot의 ConcurrentHashMap 기반 SimpleCache
   Spring 기본 CacheManager(SimpleCacheManager)를 사용하면
   ConcurrentHashMap이 그대로 JVM 메모리에 올라간 형태의 캐시가 됨.

11/17
Tcp 3way hand shake
3개의 세그먼트 전달
클라이언크 연결을 요청하는 syn를 보냄 클라이언트를 식뱔할수있는 클라이언트 순번 을 담아서
서버 요청에대해 ack 와 서버 슨번이 담긴 syn
쿨라이언트는 이에 대한 응답으로 서버 순번 +1로 ack 응답

11/18

블로킹은 함수가 호출된 후, 호출한 함수의 결과를 기다리기 위해 실행을 멈추는 상태를 의미합니다. 즉, 제어권이 반환되지 않고 대기하는 상황입니다.

@Async 가 적용된 메서드에서 발생하는 예외는 호출자에게 전파되지 않습니다. 비동기 메서드에서 예외를 정상적으로 처리하기 위해서는 별도의 비동기 예외 처리기를 사용해야 합니다

@Async 어노테이션은 프록시 기반으로 동작하기 때문에 같은 클래스 내부에서 직접 호출하는 경우 별도의 스레드에서 메서드가 실행되지 않습니다. 그리고, 비동기 메서드 내에서 생성한 트랜잭션은 상위 트랜잭션과 무관한 생명주기를 가집니다.

11/19
좋아요 데드락 해결, 락 획득하는 순서를 일관되게 코드 순서 변경
지연 Sql로 인해 쿼리 순서가 보장되지 않으므로 jpql사용하여 즉시 반영되도록함

데드 락을 해결하기 위해서 트랜잭션에서 락 획득 순서를 일관되게 할 수 있습니다. 모든 트랜잭션에서 1번 데이터, 2번 데이터 순으로 락을 획득할 시 데드 락이 발생하지 않습니다

현업에서는 디비 클라이언트를 통해 디비 커넥션을 획득하는 것도 신경써야한다.  
일단 운영 디비에 연결해서 사용한다고 할 때, 각 TAB마다 SQL 스크립트를 생성하게 되면 디비 커넥션이 부족해질 수 있다. -> 운영에 영향을 끼칠 수 있는 요인이다.  
혼자서 프로젝트할 때는 생각하지 못한 부분이었는데 디비 클라리언트를 사용할 때 이런 부분도 신경써야 하는지를 알게되었다. 디비 클라리언트마다 커넥션을 매번 획득하지 않도록 설정할 수 있는 옵션이 있다.
