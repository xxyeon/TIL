# 낙관적 락, 비관적 락은 언제 거나

> 질문 받았을 당시 낙관락, 비관락의 개념만 빠삭했고, 정적 언제 사용하는 지 깊게 생각해보지 않아서 당황했다.

sw개발에서 데이터 일관성을 유지하는 것은 매우 중요하다. 대부분 멀티스레드 환경에서 여려 사용자의 요청을 동시에 받아 처리하는데, 이때 데이터 일관성이 깨지면 예상하지 못한 데이터의 값이 저장된다. 이렇게 동시에 여러 사용자가 데이터를 수정하려고 할 때 발생할 수 있는 충돌을 방지하기 위해서 낙관락, 비관락이라는 두 가지 주요 락킹 매커니즘을 사용한다.

낙관락은 데이터베이스에 대한 변경이 드물게 발생하고, 충돌 가능성이 낮은 환경에서 유용하다. 왜냐하면 낙관락의 이름처럼 충돌이 발생하지 않을 것이라고 '낙관적'으로 가정하고, 실제로 충돌이 발생했을 때만 대응하기 때문이다. 따라서 락을 걸지 않고 데이터 변경을 하되, version 검사를 통해서 본인의 요청이 수정할 수 있는 버전인지 확인한다.  
락을 걸지 않기 때문에 요청에 대한 지연이 발생하지 않아 성능이 좋지만 데이터 무결성 보장 수준이 낮고, version 충돌에 대한 예외처리가 필요하다. 만일 동시 요청에 대한 변경이 모두 반영해야한다면, 충돌이 발생했을 때 데이터를 다시 읽고, 업데이트하는 추가작업이 필요하다.  
DynaamoDB, Redis, Firestore, ES 등 트랜잭션(락)없는 (분산 저장) NoSQL 에서 많이 사용하는 방식이다.

낙관락의 세부 방법론은 아래와 같다.

1. Timestamp-based Concurrency Control
2. Multiversion Concurrency Control(MVCC)

비관락은 데이터의 변경이 자주 발생하고, 충돌 가능성이 높은 환경에서 유용하다. 왜냐하면 비관락 이름처럼 충돌이 발생할 것이라고 '비관적'으로 가정하고, 데이터를 처음부터 잠그는 방식으로 충돌을 해결하기 때문이다. 특정 데이터에 Lock을 가진 스레드만 접근이 가능하도록 제어하는 방법으로 데이터를 읽을 때부터 해당 데이터에 락을 걸어 다른 트랜잭션이 해당 데이터를 변경할 수 없게 한다. 락을 거는 범위는 Table, Row 가 있고, 락의 종류에는 Shared Lock(읽기 잠금)과 Exclusive Lock(쓰기 잠금)이 있다.  
매 요청마다 Lock을 설정하기에 성능이 하락하고 동시성이 떨어지며, 데드락 발생 위험성이 있지만 데이터 무결성 보장 수준이 높아 읽기/쓰기 비중이 높을 때 사용한다.

비관락 세부 방법론은 아래와 같다. (데이터베이스 빌트인 락을 사용 (for update))

1. Lock-based Concurrency Control(2PL, 2PL을 확장한 방법론들)

### 결론적으로 낙관락과 비관락은 언제 사용하면 좋은가

결국 락 매커니즘은 성능 또는 데이터 일관성 두개의 트레이드오프가 있고, 이를 시스템 특성에 맞게 가져가야한다고 생각한다.
다시 정리하자면 낙관락은 성능이 중요하고 충돌 가능성이 낮은 환경에 유리하고, 비관락은 데이터의 일관성이 중요하고 충돌 가능성이 높은 환경에서 유리하다. 이 점을 잘 생각하면서 시스템에 적용해야한다.
락 매커니즘 또한 시스템 설계의 도구 중 하나이고 절대적인 정답은 없다를 다시한번 깨달았다.

참고

- [소프트웨어 개발에서의 낙관적 락과 비관적 락의 이해](https://f-lab.kr/insight/understanding-optimistic-and-pessimistic-locking)

---

undo log에 대해 설명해주세요!  
undo 로그 목적:  
프록시는 언제 생성되나요?  
JDK 동적 프록시와 CGLIB의 차이는 무엇인가요?  
외래키로 인한 데드락 예시를 설명해주세요.
