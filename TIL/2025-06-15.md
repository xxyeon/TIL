# HTTP/1.1과 HTTP/2.0에 대해서 설명해주세요.

## Http/1.0

한 연결당 하나의 요청 처리 -> RTT(Round Trip Time: 패킷이 목적지 도달 ~ 되돌아옴)
하나의 요청마다 3way handshake를 계속 열어야해서 RTT 증가
해결하기 위한 방법

1. 이미지 스플리팅: 큰 이미지를 한번에 받고 스플릿
2. 코드 압축: 코드 용량 줄려서 최대한 한꺼번에 보내기
3. 이미지 Base64 인코딩: 64진법으로 이루어진 문자열로 인코딩, 인코딩하면 HTML안에 문자열로 존재하므로 이미지를 다운받기 위한 추가 네트워크 처리가 줄어듦. 하지만 문자열로 변환하는 경우 크기가 커진다는 단점

## Http/1.1

> 연결 유지와 \*파이프라이닝을 통한 성능 최적화

\*파이프라이닝: 클라이언트가 여러 요청을 연달아 보내야할 때, 각 응답을 기다리는 것이 아니라 발생한 요청은 일단 전송하고 보는 방식

한번 TCP 연결 초기화 후 keep-alive라는 옵션으로 여러 개의 파일을 송수신. http1.0에서도 keep-alive가 있었지만 표준화가 되지 않았고 Http/1.1부터 표준화되어 기본 옵션으로 설정

기존에는 여러 요청이 있을 때 하나의 요청과 그 응답을 세트로 반복하면서 처리 -> 이게 RTT을 증가,
연결유지와 파이프라이닝 기법을 사용하면서 성능 최적화를 하였지만, 서버는 요청을 받은 순서를 지키면서 응답을 제공하는 방식으로 인해 지연이 발생하게 된다. 한개 요청안에 다수의 리소스를 처리해야한다면 리소스 개수에 비례해서 대기 시간이 길어진다.

### Hol Blocking(순서대로 처리하는 TCP 프로토콜 특성 상 발생)

서버는 모든 요청을 순서에 맞춰서 응답해야한다.
Hol Blocking은 네트워크에서 같은 큐에 있는 패킷이 그 첫번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상을 말한다. -> 리소스 다운을 직렬로 처리

### 무거운 헤더 구조(동일한 헤더를 반복하여 전송)

Http/1.1은 쿠키 등 많은 메타데이터가 들어 있고 압축이 되지 않아 무거움. -> 헤더는 압축이 안되나?
yes 본문 압축은 되는데 헤더가 안된다. 헤더가 매번 텍스트 형식으로 전달되고, keep-alive로 연결을 유지하면서 반복적으로 동일한 헤더를 매번 보내는 것이 낭비가 된다.

## Http/2.0(2015 등장, 네이버, 페이스북, 인스타그램이 사용)

SPDY 프로토콜에서 파생된 HTTP/1.X보다 지연 시간을 줄이고(Hol Blocking) 응답시간을 더 빠르게 할 수 있으며 멀티플렉싱, 헤더압축, 서버 푸시, 요청의 우선순위 처리를 지원하는 프로토콜

### 멀티플렉싱 -> 애플리케이션 계층의 HOL Blocking 해결

> 하나의 커넥션을 사용하여 요청과 응답을 병렬로 처리할 수 있는 방식

클라이언트가 서버로 여러 요청을 동시에 보내도 각 요청이 독립적으로 처리되기 대문에 애플리케이션 레이어의 Hol Blocking 문제를 해결한다.

멀티플렉싱이란 여러개의 \*스트림을 사용해서 송수신한다는 것이다.
특정 패킷이 손실되면 해당 스트림에만 영향을 주고 나머지 스트림은 멀쩡하게 동작한다. \*스트림: 시간이 지남에 따라 사용할 수 있게 되는 일련의 데이터 요소를 가리키는 양방향 데이터 흐름

스트림을 병렬적으로 송수신하고, 스프림 내의 데이터들도 프레임 단위로 쪼개진다. 애플리케이션에서 받아온 메시지를 독립된 프레임으로 쪼개고 서로 송수신한 다음 다시 조립하여 데이터를 주고 받는다.  
패킷이 프레임으로 쪼개지면서 데이터간 순서가 사라짐-> 애플리케이션 계층의 HOL Blocking 해결 (스트림 단위로 보면 특정 스트림 응답이 느리더라도 다른 스트림을 처리하면 된다.)

### 전송 계층의 HOL Blocking은 여전히 존재

https://eottabom.github.io/post/why-using-grpc/
**TCP는 순서를 보장하는 프로토콜이기 때문에, 중간에 패킷이 손실되면 해당 패킷이 재전송되어 도착할 때까지 그 이후에 도착한 패킷들도 모두 대기해야 한다.**  
이로 인해 **모든 스트림이 공유하는 TCP 연결 전체가 일시적으로 지연**되며, **결과적으로 각 스트림의 데이터 처리까지 영향을 받게 된다**. 이 현상이 바로 **전송 계층에서의 HOL Blocking**이다.되면, 손실된 패킷을 다시 전송받을 때까지 나머지 패킷의 처리가 지연된는 의미

바이너리 프레임 계층이 생기고, 여기서 메시지를 프레임이라는 단위로 분할. 이 프레임을 바이너리로 인코딩(파싱이나 전송 속도 , 오류 가능성 저하)

### Stream Prioritization

리소스간 우선순위를 설정 가능
스트림에 우선순위 가중치를 둬서 스트림 우선순위 결정

### server push

클라이언트에서 요청하지 않은 요청을 서버가 알아서 보낼 수 있다. html 안에 css. js 리소스가 있다면 서버가 알아서 보내주는 것, 서버가 클라이언트 대신 PUSH_PROMISE로 요청을 생성해서 보내주는 것이다.

```
스트림 1 (index.html): [HEADERS] (index.html 요청에 대한 응답) [PUSH_PROMISE] for style.css (스트림 2 예약) [PUSH_PROMISE] for script.js (스트림 3 예약)
```

## 직렬/병렬, 동기/비동기

직렬: 작업을 요청 순서대로 처리  
병렬: 여러 작업을 요청 순서와 상관없이 처리  
동기: 이전 작업이 완료 된 후 현재 작업 처리  
비동기: 이전 작업의 완료 여부와 상관없이 현재 작업 처리
