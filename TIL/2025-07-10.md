### 잘못된 개념 재정립 - MVCC와 낙관락

MVCC 의 목적에 대해 오해가 있었다.
MVCC로 인해 다양한 트랜잭션 격리 수준이 나왔다? 라고 이해했는데, 그게 아니라 락 없이 일관된 읽기 제공하는 것이다. 낙관락처럼 락의 방법론 중 하나이며, 언두 로그에 다양한 이전 버전의 레코드 값을 관리하면서 버전 충돌이 나지 않게 해준다.

내가 좋아요 동시성 처리에서 낙관락 처리에서 버전 충돌로 인해 해결이 안되었었다. 지금 생각해보면 MySQL은 MVCC를 지원해서 버전 충돌이 나면 안된다. 그때 당시 MVCC 기능 목적에 대한 이해가 부족해서 낙관락을 적용하고 버전충돌이 났음에도 이상하게 생각하지 않고 넘어갔다.

비관락을 적용한 이유도 낙관락에서 해결이 안되어서 비관락으로 했다. 근데 비관락은 데이터 일관성 보장은 확실하지만, 성능이 떨어진다.  
만일 엄청 인기 있는 인플루언서가 게시글을 올려 좋아요 트래픽이 많다면 락으로 인해 성능이 느릴 것이다. 금융 도메인 같이 고객의 자산을 관리해야한다면 비관락을 적용하는게 맞겠지만.. 일반적인 애플리케이션 같은 경우 트래픽이 커질는 것에 항상 대비해야하므로 비관락을 적용할 필요가 없다는 생각이 들었다.
그리고 MySQL뿐 아니라 레코드 레벨의 트랜잭션을 지원한느 DBMS가 제공하는 기능이다.

[트랜잭션 시뮬레이션](../Database/transaction.md)한 적이 있는데 이때 실행한 시뮬레이션에 잘못된게 있었다.  
두번째 상황에서 트랜잭션이 커밋되지 않은 상황에서 다른 트랜잭션이 수정 요청이 들어오면 대기를 하는데, 대기하지 않고 바로 수정한다고 되어 있다.

그리고 다시 시뮬레이션 하면서 깨달은게 있다. 위 상황에 대한 잘못을 인지하지 못한게 트랜잭션의 독립성(격리성)을 간과했다는 점. 독립성은 다른 트랜잭션의 작업에 끼어들지 못하는 건데, 이점을 간과해서 트랜잭션 커밋 전에 다른 트랜잭션이 작업을 수행한다고 생각했다. 정확히 말하면 update 쿼리는 X-lock을 걸린다(Xlock은 데이터를 수정하는 DML,DDL 작업에 걸린다.). 따라서 다른 트랜잭션이 해당 레코드를 변경하고 트랜잭션이 끝나지 않았다면(commit전이라면) 해당 레코드에 x-lock이 걸려있을 것이다. 따라서 lock이 풀리기를 기다리는 것이다. (이름이 베타적 락인 이유도 나 말고 다른 것은 허용하지 않겠다. 이므로 베타락이라고 부른다고 한다.)

트랜잭션이 시작할 때 커밋이 완료된 상황을 스냅샷 찍어놓고 그것과 비교한다. 트랜잭션 3개가 시작한다고 해보고, 트랜잭션 1, 2, 3이 차례로 실행된다(auto commit이 아니라는 전제).  
트랜잭션 1이 데이터 수정 후 커밋, 트랜잭션 2가 조회 하면 트랜잭션 2는 트랜잭션 1이 수정된 내용을 보고 스냅샷 찍는다.
트랜잭션 1이 데이터 수정 후 커밋, 트랜잭션 2는 데이터 수정 후 커밋하지 않았을 때, 트랜잭션 3은 트랜잭션 1이 수정된 데이터를 본다. 이때 트랜잭션 2가 커밋하면 트랜잭션 3은 여전히 트랜잭션 1의 데이터를 본다. 트랜잭션 2가 트랜잭션 3보다 먼저 시작해도 커밋은 트랜잭션 3이 시작한 이후에 하였으므로 트랜잭션 3이 시작한 이후로 커밋 전(트랜잭션 끝나기)까지 트랜재션 2가 변경한 데이터를 볼 수 없다.

아주 간단한건데 트랜잭션 id 랑 약간 헷갈렸다. "mvcc의 언두로그를 읽을 때 자신의 트랜잭션 id보다 작은 가장 최신값을 읽는다" 에 꽂혀서 MySQL 트랜잭션의 기본 격리 수준(Repeatable Read)에 대한 기본적인 개념에 대해 망각하고 트랜잭션 id에 집착해서 문제였다... 참고로 Read Commited 수준에서는 트랜잭션 3이 트랜잭션 2가 변경 후 커밋한 데이터를 읽을 수 있다.
