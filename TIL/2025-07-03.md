# 핫스팟의 가비지 수집

## TLAB(Thread Local Allocation Buffer)

TLAB란 새로운 객체가 생성되면 에덴 영역에 할당되는데, JVM이 에덴 영역을 여러 버퍼로 나눠 애플리케이션 스레드가 새 객체를 할당하는 구역으로 활용하여 배포한다. 이렇게 에덴 영역을 스레드 별로 관리해줄 수 있도록하는 버퍼이다.

## 반구형 수집

반구형(방출)수집기는 두개의 공간을 사용하여, 장수하지 못하는 객체를 임시로 저장하는 장소로 사용된다. 장수하지 못하는 객체인데 바로 테뉴어드 공간으로 승격하면 테뉴어드 공간만 차지하게 되기 때문에 중간 저장소를 만든 것이다.

이 두 공간은 다음과 같은 특성을 지닌다.

1. 수집기가 라이브 반구를 수집할 때 객체들은 다른 반구로 압착시켜 옮기고 수집된 반구는 비워서 재사용한다.
2. 절반의 공간을 항상 비어 있어야한다.

핫스팟은 이 반구형 기법과 에덴 공간을 접목시켜 영 세대를 수집 -> 서바이버라고 부른다.

## 병렬 수집기

자바 8 이전까지 JVM 디폴트 가비지 수집기는 병렬 수집기였다. 병렬 수집기는 youn GC, full GC 모두 STW를 발생하고, 애플리케이션 스레드를 모두 정지 후 가용 cpu 코어를 총동원하여 가능한 빨리 메모리를 수집한다.

### young 세대 병렬 수집

스레드가 에덴에 객체를 할당하려는데 자신이 할당받은 TLAB 공간은 부족하고 JVM은 새 TLAB를 할당해줄 수 없을 때 발생  
전체 애플리케이션 스레드가 중단되면 핫스팟은 영 세대(에덴 및 비어있지 않은 서바이버 공간)을 뒤져서 가비지 아닌 객체를 골라냅니다. 이때 GC 루트(와 올드 세대에서 출발하는 GC 루트를 식별하기 위한 카드 테이블)을 병렬 마스킹 스캔 작업의 출발점으로 삼는다.  
살아있는 객체만 건드려(GC 루트, 마트 테이블을 출발점으로 bfs하여 탐색) 약한 세대별 가설의 이점을 최대한 활용(단면, old의 참조를 받는 young gen은 거의 없다) -> 살아있는 객체가 거의 없다는 점을 활용하여 STW 시간 단축

### old 세대 병렬 수집

Parallel GC는 객체를 방출하는 반구형 수집기이지만, ParallelOld GC는 하나의 연속된 메모리 공간에서 압착하는 수집기이다.

- 영세대 GC: 영 공간의 점유 상태는 GC 이벤트가 발생할 때마다 메모리 할당 및 소거가 일어나면서 급격하게 변함(단명하는 객체가 대부분 + 새로운 객체에 계속 메모리 할당, 단명 객체에 대한 메모리 소거)
- 올드 세대 GC: GC 이벤트가 잘 발생하지 않음. 큰 객체가 테뉴어드 세대에 직접 생성될 때 + 영 세대 객체가 승격 혹은 올드/풀 수집이 일어나 객체를 재탐색 후 다시 배치하는 등의 수집이 일어날 때만 변함

## 병렬 수집기의 한계

young gen에서 발생하는 stw는 문제되지 않는다(극 소수 객체만 살아남기 때문에, 죽은 객체는 건드리지 않으므로 stw가 굉장히 짧다.)
old gen은 young gen 메모리 크기보다 7배나 크다. 또한 영역 내 살아 있는 객체 수 만큼 마킹 시간도 늘어나는데, old 객체는 장수한 객체이므로 풀 수집 시 이들 중 상당수는 살아남을 공산도 크다.
또한 올드 수집의 가장 큰 약점은 STW가 힙 크기에 비례한다.
왜 TLAB 할당이 영세대 메모리 할당 성능을 끌엉ㄹ리지만 수집 사이클에는 도움이 안된다고 할까

- 책의 코드 참고
- 손 쉽게 스레드를 생성하는 자바의 능력은 플랫폼으로서 아주 강력하지만, 새 스레드는 곧 실행 스택을 의미하고 실행 스택을 각 프레임은 GC root를 의미한다. -> 가비지 수집관점에서 보면 전체적인 모양새가 점점 더 복잡해진다.
- 즉, gc root가 하나 더 생기는 셈이다. -> 마킹 시간이 늘어난다?

## 할당의 역할

자바의 가비지 수집 프로세스는 보통 유입된 메모리 할당 요청을 수용하기에 메모리가 부족할 때 작동하여 필요한 만큼 메모리를 공급해준다. -> GC는 메모리 할당 요청을 수용하기 부족할 때 그때그때 발생한다.
GC 특징: 불확정적으로 불규칙하게 발생한다. -> 가비지 수집 로그를 기존이 시계열 해석(time series analysis) 방법으로 처리하기 어렵다
GC 사이클은 하나 이상의 힙 메모리 공간이 꽉 채워져 더 이상 객체를 생성할 공간이 없을 때 일어난다.

GC가 발생하면 모든 애플리케이션 스레드가 멈춘다( 메모리 할당 요청을 수용할 수 없으니 다른 객체 생성도 못함)
살아남은 객체의 크기가 서바이버보다 크면 테뉴어드로 보낼 수 있다. 꼭 age 임계치에 달하지 않아도 공간이 부족하면 테뉴어드로 보낸다고 이해
