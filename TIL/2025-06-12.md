### 디스크 접근 시간에 대해서 설명해주세요.

답변: 디스크에 저장된 데이터를 읽기위해 디스크 헤더를 읽으려는 데이터가 있는 곳으로 옮기는 시간을 말합니다. 그래서 디스크 접근 시간을 줄이기 위해서는 이 헤더를 옮기는 시간을 최소화하는 것을 말합니다.
헤더의 이동시간을 최소화하기 위해서는 데이터가 연속적으로 있을 경우 헤더의 이동이 한번 이루어지므로 연속된 공간에 데이터가 있으면 순차적으로 데이터를 읽을 수 있습니다.
하지만 대부분 디스크 접근은 랜덤 접근으로 이루어지기 때문에 데이터를 캐싱하여 디스크 까지 가지 않도록 하는 방법이 있습니다.

최근에는 원판을 돌리는 하드디스크 보다 SSD를 사용하면서 디스크 접근에 대한 시간을 많이 단축했다고는 하지만, 애플리케이션 실행에서 디스크 접근에서 시간이 가장 오래걸린다는 것을 변하지 않았으므로, 애플리케이션 응답속도를 향상하기 위해서는 디스크 접근을 얼마나 빠르게 하느냐에 따라 달렸습니다.
SSD? 기계식 장치가 아닌 플래시 메모리를 활용하여 랜덤 I/O 접근에 빠른 효율을 보인다.

#### 추가로 생각해볼 점

[하드디스크에서 랜덤 액세스보다 순차 액세스 더욱 빠른 이유](https://velog.io/@ddangle/%EC%88%9C%EC%B0%A8Sequential-IO%EC%99%80-%EB%9E%9C%EB%8D%A4Random-IO)

답변: 랜덤 액세스 같은 경우 읽으려는 데이터 수 만큼 헤더를 움직여얗지만, 순차 액세스 같은 경우 한번의 이동만으로 순차적으로 데이터를 읽을 수 있기때문이다. 데이터베이스에서 full scan이 순차 접근이고, index를 탐색하는 경우가 랜덤 I/O이다.

---

놓친 키워드

- 데이터 블록
- 디스크 접근 시간(탐색시간 + 회전 지연시간 + 데이터 전송 시간)
- 탐색 시간(seek time)

## 추가 학습 필요

### SSD

SSD는 디스크 원판(플래터)를 가지지 않으므로 랜덤 I/O와 순차 I/O의 차이가 없어보이지만, 실제론 그렇지 않다. SSD 에서도 랜덤 I/O는 순차 I/O보다 처리율(Throughput)이 떨어진다.  
이유는 다음과 같다.

- SSD는 물리적으로 NAND 플래시 메모리에 저장된 데이터를 직접 읽고 쓰는 것이 아니라, 내부적으로 논리적인 주소를 물리적인 주소로 매핑하는 매핑 테이블을 사용한다.
- 매핑 테이블을 업데이트 하려면 NAND 플래시 메모리의 물리적인 위치를 찾아야하므로 랜덤 I/O 의 경우에는 이 과정이 추가로 발생하여 전체 처리율이 떨어지게 됩니다.  
  -> 매핑 테이블을 왜 업데이트? page fault가 발생하면 하드디스크로 가서 메모리에 빈 프레임이 있다면 페이지 단위로 프로세스 올리고, 없으면 스케줄링으로 swap out 해서 메모리 빈 공간 생성 후에 페이지 올린 후 페이지 테이블에 정보 업데이트 해준다.
- 만약 순차 I/O 라면, 논리적인 위치를 통해 알아낸 물리적인 위치를 통해 나머지 항목들도 업데이트해주면 된다.
  연속된 메모리에 페이지가 있으므로 한번의 물리적 위치를 알아내는 작업을 하면 나머지는 이어진 주소를 한꺼번에 가져와서 페이지 테이블에 업데이트한는건가?

### 가상 메모리

메모리 관리 기법 중 하나로, 작은 메모리 공간만으로도 크기가 큰 프로세스를 실행할 수 있도록 메모리 공간을 가상으로 제공하는 것을 말한다.  
가상 메모리의 가상 주소를 MMU(메모리 관리 장치)에 의해 제 주소로 변환된다.

#### 페이지 테이블

가상 메모리는 실제 주소가 매핑되어 있고, 프로세스의 주소 정보가 들어있는 '페이지 테이블'로 관리 된다.

### TLB

메모리와 CPU 사이에 있는 주소 변환을 위한 캐시. 페이지 테이블에 있는 리스트를 보관하여 CPU가 페이지 테이블까지 가지 않도록하여 속도를 향상시킬 수 있는 캐시 계층이다.

### 버퍼풀과 디스크 접근으로 본 디스크 I/O

순차 접근(Full Scan): 버퍼풀의 메모리를 많이 사용하므로 버퍼풀을 자주 비워줘야하고, 디스크 접근이 많음. 다만 랜덤 I/O 보다 접근이 빠른다.

랜덤 접근(Random Scan): 버퍼풀을 상대적으로 적게 사용한다. 많은 블록을 저장할 수 있다. -> 디스크 접근을 줄일 수 있다. 랜더 I/O 이므로 디스크 접근이 느림

### RDBMS와 가상 메모리 ->

운영체제가 RDBMS를 실행할 때 가상 메모리를 사용하여 실행하고, RDBMS에서 사용하는 메모리(글로벌 메모리 영역(예, 버퍼풀, 언두로그), 세션 메모리 영역(커넥션 버퍼) 등)도 가상 메모리에 포함되어 있다.  
따라서 메모리 공간이 부족하다면 버퍼풀이 하드디스크로 swap out되는 경우가 있을 수도 있겠다는 생각이 들었고, 이런 경우가 발생하면 쿼리 실행에 큰 성능 저하가 보일 것으로 생각된다.
