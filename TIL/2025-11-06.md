# Index

## 인덱스란?

데이터를 빠르게 조회하기 위한 자료구조이다.
해시 인덱스와 B Tree 인덱스 등이 있다. 일반적으로 B Tree 구조가 사용된다.

## 인덱스 자료구조

MySQL innoDB를 기준으로 설명하자면 B+Tree와 같은 변형 B-Tree 자료구조를 이용해서 인덱스를 구현한다. 기본 토대는 B-Tree 인덱스이므로 이를 기준으로 설명.
B-Tree 인덱스는 칼럼의 값을 변형하지 않고 인덱스 구조체 내에서 항상 정렬된 상태를 유지한다.
B-Tree 에서는 크게 3개 노드가 존재함. 루트, 브랜치, 리프 노드가 존재한다. 리프노드에는 실제 데이터 레코드를 찾아가기 위한 주소값을 가지고 있다.
InnoDB 스토리엔진에서는 세컨더리 인덱스의 리프노드에서는 레코드이 PK가 저장된다. 따라서 세컨더리 인덱스 검색에서는 레코드를 읽기위해 PK를 가지고 있는 B-Tree를 다시 한번 검색해야한다.

- 세컨더리 인덱스 -> 클러스터드 인덱스 -> 실제 데이터 테이블

### 참고

클러스터드 인덱스에서 실제 테이블로 넘어가는 과정에서 클러스터디 인덱스의 리프노드에 PK가 존재하는 페이지 번호가 있는데, 이 페이지 번호를 찾기 위해 풀 스캔이 발생한다.

## MySQL 스캔 방식

인덱스 레인지 스캔, 인덱스 풀 스캔, 루스 인덱스 스캔 방식이 있다.

### 인덱스 레인지 스캔

인덱스 레인지 스캔은 검색할 인덱스 범위가 결정되었을 경우 사용하며 가장 빠르다.

- 인덱스의 조건을 만족하는 값이 저장된 시작 리프 노드를 찾는다. (index seek)
- 시작 리프 노드부터 필요한 만큼 인덱스를 차례대로 읽는다. (index scan)
- 인덱스 키와 레코드 주소를 이용해 저장된 페이지를 가져오고 레코드를 읽어온다.

레코드를 읽어오는 과정에서 랜덤 IO가 발생할 수 있다. 읽어야한 레코드가 전체 20% ~ 25% 의 경우에는 풀 테이블 스캔(순차 IO를 이용)이 더욱 좋을 수도 있다.

### 인덱스 풀 스캔

인덱스 풀 스캔은 인덱스는 사용하지만 인덱스를 처음부터 끝까지 모두 읽는 방식이다.

- 인덱스를 ABC 순서로 만들었는데 B 혹은 C로 검색하는 경우
- 인덱스를 생성하는 목적은 아니지만, 그래도 풀 테이블 스캔보다는 낫다.(데이터 레코드까지 읽지 않는 경우)

### 루스 인덱스 스캔

루스 인덱스 스캔은 듬성듬성하게 인덱스를 읽는 것을 의미한다. (앞서 언급한 인덱스 스캔은 타이트 인덱스 스캔으로 분류 된다.)

- 중간에 필요하지 않은 인덱스키 값을 무시하고 다음으로 넘어가는 형태로 처리
- group by, max(), min() 함수에 대해 최적화하는 경우에 사용
